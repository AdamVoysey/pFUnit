! -*-f90-*-
! Minimum support is for expected and actual arguments to have the same
! kind.
@tkr_parameters minimal
[(real,  32, rank)]
[(real,  64, rank)]
[(real, 128, rank)]
@end tkr_parameters

@tkr_parameters useful
! exact TKR matches
[(real,  32, rank), (real,  32, rank), (real,  32, 0)]
[(real,  64, rank), (real,  64, rank), (real,  64, 0)]
[(real, 128, rank), (real, 128, rank), (real, 128, 0)]
!
! expected is default real
[(real, default, rank), (real,  32, rank), (real,  32, 0)]
[(real, default, rank), (real,  64, rank), (real,  64, 0)]
[(real, default, rank), (real, 128, rank), (real, 128, 0)]
!
! tolerance is default real
[(real,  32, rank), (real,  32, rank), (real, default, 0)]
[(real,  64, rank), (real,  64, rank), (real, default, 0)]
[(real, 128, rank), (real, 128, rank), (real, default, 0)]
!
! expected and tolerance are default real
[(real, default, rank), (real,  32, rank), (real, default, 0)]
[(real, default, rank), (real,  64, rank), (real, default, 0)]
[(real, default, rank), (real, 128, rank), (real, default, 0)]
!
! expected is default integer
[(integer, default, rank), (real,  32, rank), (real,  32, 0)]
[(integer, default, rank), (real,  64, rank), (real,  64, 0)]
[(integer, default, rank), (real, 128, rank), (real, 128, 0)]
!
! expected is default integer and tolerance is default real
[(integer, default, rank), (real,  32, rank), (real, default, 0)]
[(integer, default, rank), (real,  64, rank), (real, default, 0)]
[(integer, default, rank), (real, 128, rank), (real, default, 0)]
!
!
! Allow expected to be conformable scalar
! exact TKR matches
[(real,  32, 0), (real,  32, rank), (real,  32, 0)]
[(real,  64, 0), (real,  64, rank), (real,  64, 0)]
[(real, 128, 0), (real, 128, rank), (real, 128, 0)]
!
! expected is default real
[(real, default, 0), (real,  32, rank), (real,  32, 0)]
[(real, default, 0), (real,  64, rank), (real,  64, 0)]
[(real, default, 0), (real, 128, rank), (real, 128, 0)]
!
! tolerance is default real
[(real,  32, 0), (real,  32, rank), (real, default, 0)]
[(real,  64, 0), (real,  64, rank), (real, default, 0)]
[(real, 128, 0), (real, 128, rank), (real, default, 0)]
!
! expected and tolerance are default real
[(real, default, 0), (real,  32, rank), (real, default, 0)]
[(real, default, 0), (real,  64, rank), (real, default, 0)]
[(real, default, 0), (real, 128, rank), (real, default, 0)]
!
! expected is default integer
[(integer, default, 0), (real,  32, rank), (real,  32, 0)]
[(integer, default, 0), (real,  64, rank), (real,  64, 0)]
[(integer, default, 0), (real, 128, rank), (real, 128, 0)]
!
! expected is default integer and tolerance is default real
[(integer, default, 0), (real,  32, rank), (real, default, 0)]
[(integer, default, 0), (real,  64, rank), (real, default, 0)]
[(integer, default, 0), (real, 128, rank), (real, default, 0)]
@end tkr_parameters

#include "unused_dummy.fh"

module pf_AssertReal_{rank}d_mod
   use, intrinsic :: iso_fortran_env, only: REAL32
   use, intrinsic :: iso_fortran_env, only: REAL64
   use, intrinsic :: iso_fortran_env, only: REAL128
   use pf_KeywordEnforcer_mod
   use pf_SourceLocation_mod
   use pf_AssertUtilities_mod
   implicit none
   private

   public :: AssertEqual
   public :: AssertNotEqual
   public :: AssertLessThan
   public :: AssertLessThanOrEqual
   public :: AssertGreaterThan
   public :: AssertGreaterThanOrEqual
   
   public :: AssertAssociated

   @overload(AssertEqual, useful)
   @overload(AssertNotEqual, useful)
   @overload(AssertLessThan, useful)
   @overload(AssertLessThanOrEqual, useful)
   @overload(AssertGreaterThan, useful)
   @overload(AssertGreaterThanOrEqual, useful)

   @overload(AssertAssociated, minimal)

   @overload(assert_equal, minimal)
   @overload(assert_not_equal, minimal)
   @overload(assert_less_than, minimal)
   @overload(assert_less_than_or_equal, minimal)
   @overload(assert_greater_than, minimal)
   @overload(assert_greater_than_or_equal, minimal)


   integer, parameter :: MAX_LEN_REAL_AS_STRING = 40

contains


   @template(AssertEqual,[expected,actual,tolerance])
   subroutine {name}(expected, actual, tolerance, message, location)
      {expected.type} (kind={expected.kind}), intent(in) :: expected {expected.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: actual {actual.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance      
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location


      real(kind=kind(actual)) :: t
      real(kind=kind(actual)), allocatable :: e {actual.dims}

      if (.not. conformable(shape(expected), shape(actual))) then
         call fail_not_conformable(shape(expected), shape(actual), message=message, location=location)
         return
      end if

      ! Trick to get e to have the right shape even if "expected" is a scalar.
      e = 0*actual + expected

#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = real(tolerance, kind(actual))
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_equal(e, actual, t, message=message, location=location)

   end subroutine {name}
   @end template

   @template(assert_equal,[actual])
   subroutine {name}(expected, actual, tolerance, unused, message, location)
      {actual.type} (kind={actual.kind}), intent(in) :: expected {actual.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: actual {actual.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(actual)) :: e, a, d

#if {actual.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: expected_str
      character(len=MAX_LEN_REAL_AS_STRING) :: actual_str
      character(len=3*MAX_LEN_REAL_AS_STRING) :: diff_str

      _UNUSED_DUMMY(unused)

#if {actual.rank} == 0
      ! scalar
      if (.not. (abs(actual - expected) <= tolerance)) then
         e = expected
         a = actual
      else
         return
      end if
         
#else
      if (.not. all(abs(actual - expected) <= tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. abs(actual-expected) <= tolerance))
         e = expected({actual.multi_index})
         a = actual({actual.multi_index})
      else
         return
      end if
#endif
      d = a - e

      ! Wish: allocatable strings were useful as internal files ...
      write(expected_str,'(g0)') e
      write(actual_str,'(g0)') a
      write(diff_str,'("<",g0,"> (greater than tolerance of ",g0,")")') d, tolerance
      
#if {actual.rank} == 0
      call fail_not_equal(trim(expected_str), trim(actual_str), trim(diff_str), &
           & message=message, location=location)
#else
      call fail_not_equal(trim(expected_str), trim(actual_str), trim(diff_str), index=i, &
           & message=message, location=location)
#endif
   end subroutine {name}
   @end template



   @template(AssertNotEqual,[expected,actual,tolerance])
   recursive subroutine {name}(expected, actual, tolerance, message, location)
      {expected.type} (kind={expected.kind}), intent(in) :: expected {expected.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: actual {actual.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(actual)) :: t
      real(kind=kind(actual)), allocatable :: e {actual.dims}

      if (.not. conformable(shape(expected), shape(actual))) then
         call fail_not_conformable(shape(expected), shape(actual), message=message, location=location)
         return
      end if

      e = real(expected, kind(actual))
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = real(tolerance, kind(actual))
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_not_equal(e, actual, t, message=message, location=location)

   end subroutine {name}
   @end template


   @template(assert_not_equal,[actual])
   recursive subroutine {name}(expected, actual, tolerance, unused, message, location)
      {actual.type} (kind={actual.kind}), intent(in) :: expected {actual.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: actual {actual.dims}
      {actual.type} (kind={actual.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(actual)) :: e, a, d
#if {actual.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: actual_str
      character(len=3*MAX_LEN_REAL_AS_STRING) :: diff_str

      _UNUSED_DUMMY(unused)

#if {actual.rank} == 0
      ! scalar
      if (.not. (abs(actual - expected) > tolerance)) then
         e = expected
         a = actual
      else
         return
      end if
         
#else
      if (.not. all(abs(actual - expected) > tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. abs(actual-expected) > tolerance))
#if {actual.rank} == 0
         e = expected
#else
         e = expected({actual.multi_index})
#endif
         a = actual({actual.multi_index})
      else
         return
      end if
#endif
      d = a - e
      
      ! Wish: allocatable strings were useful as internal files ...
      write(actual_str,'(g0)') a
      write(diff_str,'(g0," less than or equal to tolerance of ",g0)') d, tolerance
      
#if {actual.rank} == 0
      call fail_equal(trim(actual_str), difference=trim(diff_str), &
           & message=message, location=location)
#else
      call fail_equal(trim(actual_str), difference=trim(diff_str), index=i, &
           & message=message, location=location)
#endif
      
   end subroutine {name}
   @end template


   @template(AssertLessThan,[lhs,rhs,tolerance])
   recursive subroutine {name}(lhs, rhs, tolerance, message, location)
      {lhs.type} (kind={lhs.kind}), intent(in) :: lhs {lhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)), allocatable :: l {rhs.dims}
      real(kind=kind(rhs)) :: t

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

      l = rhs
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = tolerance
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_less_than(l, rhs, t, message=message, location=location)

   end subroutine {name}
   @end template

   
   @template(assert_less_than,[rhs])
   recursive subroutine {name}(lhs, rhs, tolerance, unused, message, location)
      {rhs.type} (kind={rhs.kind}), intent(in) :: lhs {rhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
      real (kind={rhs.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)) :: l, r
#if {rhs.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: lhs_str
      character(len=MAX_LEN_REAL_AS_STRING) :: rhs_str

      _UNUSED_DUMMY(unused)

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

#if {rhs.rank} == 0
      ! scalar
      if (.not. (lhs < rhs + tolerance)) then
         l = lhs
         r = rhs
      else
         return
      end if
         
#else
      if (.not. all(lhs < rhs + tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. (lhs < rhs + tolerance)))
#if {rhs.rank} == 0
         l = lhs
#else
         l = lhs({rhs.multi_index})
#endif
         r = rhs({rhs.multi_index})
      else
         return
      end if
#endif

      ! Wish: allocatable strings were useful as internal files ...
      write(lhs_str,'(g0)') l
      write(rhs_str,'(g0)') r
      
#if {rhs.rank} == 0
      call fail_not_less_than(trim(lhs_str), trim(rhs_str), &
           & message=message, location=location)
#else
      call fail_not_less_than(trim(lhs_str), trim(rhs_str), index=i, &
           & message=message, location=location)
#endif
      
   end subroutine {name}
   @end template


   @template(AssertLessThanOrEqual,[lhs,rhs,tolerance])
   recursive subroutine {name}(lhs, rhs, tolerance, message, location)
      {lhs.type} (kind={lhs.kind}), intent(in) :: lhs {lhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)), allocatable :: l {rhs.dims}
      real(kind=kind(rhs)) :: t

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

      l = rhs
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = tolerance
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_less_than_or_equal(l, rhs, t, message=message, location=location)

   end subroutine {name}
   @end template

   
   @template(assert_less_than_or_equal,[rhs])
   recursive subroutine {name}(lhs, rhs, tolerance, unused, message, location)
      {rhs.type} (kind={rhs.kind}), intent(in) :: lhs {rhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
      real (kind={rhs.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)) :: l, r
#if {rhs.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: lhs_str
      character(len=MAX_LEN_REAL_AS_STRING) :: rhs_str

      _UNUSED_DUMMY(unused)

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

#if {rhs.rank} == 0
      ! scalar
      if (.not. (lhs <= rhs + tolerance)) then
         l = lhs
         r = rhs
      else
         return
      end if
         
#else
      if (.not. all(lhs <= rhs + tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. (lhs <= rhs + tolerance)))
#if {rhs.rank} == 0
         l = lhs
#else
         l = lhs({rhs.multi_index})
#endif
         r = rhs({rhs.multi_index})
      else
         return
      end if
#endif

      ! Wish: allocatable strings were useful as internal files ...
      write(lhs_str,'(g0)') l
      write(rhs_str,'(g0)') r
      
#if {rhs.rank} == 0
      call fail_not_less_than_or_equal(trim(lhs_str), trim(rhs_str), &
           & message=message, location=location)
#else
      call fail_not_less_than_or_equal(trim(lhs_str), trim(rhs_str), index=i, &
           & message=message, location=location)
#endif
      
   end subroutine {name}
   @end template



   @template(AssertGreaterThan,[lhs,rhs,tolerance])
   recursive subroutine {name}(lhs, rhs, tolerance, message, location)
      {lhs.type} (kind={lhs.kind}), intent(in) :: lhs {lhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)), allocatable :: l {rhs.dims}
      real(kind=kind(rhs)) :: t

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

      l = rhs
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = tolerance
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_greater_than(l, rhs, t, message=message, location=location)

   end subroutine {name}
   @end template

   
   @template(assert_greater_than,[rhs])
   recursive subroutine {name}(lhs, rhs, tolerance, unused, message, location)
      {rhs.type} (kind={rhs.kind}), intent(in) :: lhs {rhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
      real (kind={rhs.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)) :: l, r
#if {rhs.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: lhs_str
      character(len=MAX_LEN_REAL_AS_STRING) :: rhs_str

      _UNUSED_DUMMY(unused)

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

#if {rhs.rank} == 0
      ! scalar
      if (.not. (lhs > rhs - tolerance)) then
         l = lhs
         r = rhs
      else
         return
      end if
         
#else
      if (.not. all(lhs > rhs - tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. (lhs > rhs - tolerance)))
#if {rhs.rank} == 0
         l = lhs
#else
         l = lhs({rhs.multi_index})
#endif
         r = rhs({rhs.multi_index})
      else
         return
      end if
#endif

      ! Wish: allocatable strings were useful as internal files ...
      write(lhs_str,'(g0)') l
      write(rhs_str,'(g0)') r
      
#if {rhs.rank} == 0
      call fail_not_greater_than(trim(lhs_str), trim(rhs_str), &
           & message=message, location=location)
#else
      call fail_not_greater_than(trim(lhs_str), trim(rhs_str), index=i, &
           & message=message, location=location)
#endif
      
   end subroutine {name}
   @end template




   @template(AssertGreaterThanOrEqual,[lhs,rhs,tolerance])
   recursive subroutine {name}(lhs, rhs, tolerance, message, location)
      {lhs.type} (kind={lhs.kind}), intent(in) :: lhs {lhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      {tolerance.type} (kind={tolerance.kind}), optional, intent(in) :: tolerance
#else
      {tolerance.type} (kind={tolerance.kind}), intent(in) :: tolerance
#endif
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)), allocatable :: l {rhs.dims}
      real(kind=kind(rhs)) :: t

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

      l = rhs
#if {tolerance.kind_value} == _REAL_DEFAULT_KIND
      if (present(tolerance)) then
         t = tolerance
      else
         t = 0
      end if
#else
      t = tolerance
#endif

      call assert_greater_than_or_equal(l, rhs, t, message=message, location=location)

   end subroutine {name}
   @end template

   
   @template(assert_greater_than_or_equal,[rhs])
   recursive subroutine {name}(lhs, rhs, tolerance, unused, message, location)
      {rhs.type} (kind={rhs.kind}), intent(in) :: lhs {rhs.dims}
      {rhs.type} (kind={rhs.kind}), intent(in) :: rhs {rhs.dims}
      real (kind={rhs.kind}), intent(in) :: tolerance
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      real(kind=kind(rhs)) :: l, r
#if {rhs.rank} != 0
      integer, allocatable :: i(:)
#endif
      character(len=MAX_LEN_REAL_AS_STRING) :: lhs_str
      character(len=MAX_LEN_REAL_AS_STRING) :: rhs_str

      _UNUSED_DUMMY(unused)

      if (.not. conformable(shape(lhs), shape(rhs))) then
         call fail_not_conformable(shape(lhs), shape(rhs), message=message, location=location)
         return
      end if

#if {rhs.rank} == 0
      ! scalar
      if (.not. (lhs >= rhs - tolerance)) then
         l = lhs
         r = rhs
      else
         return
      end if
         
#else
      if (.not. all(lhs >= rhs - tolerance)) then
         ! index of first difference is
         i = maxloc(merge(1,0, .not. (lhs >= rhs - tolerance)))
#if {rhs.rank} == 0
         l = lhs
#else
         l = lhs({rhs.multi_index})
#endif
         r = rhs({rhs.multi_index})
      else
         return
      end if
#endif

      ! Wish: allocatable strings were useful as internal files ...
      write(lhs_str,'(g0)') l
      write(rhs_str,'(g0)') r
      
#if {rhs.rank} == 0
      call fail_not_greater_than(trim(lhs_str), trim(rhs_str), &
           & message=message, location=location)
#else
      call fail_not_greater_than(trim(lhs_str), trim(rhs_str), index=i, &
           & message=message, location=location)
#endif
      
   end subroutine {name}
   @end template


   @template(AssertAssociated,[tkr])
   subroutine {name}(p, t, unused, message, location)
      {tkr.type} (kind={tkr.kind}), pointer, intent(in) :: p {tkr.dims}
      {tkr.type} (kind={tkr.kind}), target, intent(in) :: t {tkr.dims}
      class (KeywordEnforcer), optional, intent(in) :: unused
      character(*), optional, intent(in) :: message
      type (SourceLocation), optional, intent(in) :: location

      _UNUSED_DUMMY(unused)

      if (.not. associated(p, t)) then
         call fail_not_associated(message=message, location=location)
      end if

   end subroutine {name}
   @end template


   @instantiate(AssertEqual, useful)
   @instantiate(AssertNotEqual, useful)
   @instantiate(AssertLessThan, useful)
   @instantiate(AssertLessThanOrEqual, useful)
   @instantiate(AssertGreaterThan, useful)
   @instantiate(AssertGreaterThanOrEqual, useful)

   @instantiate(AssertAssociated, minimal)

   @instantiate(assert_equal, minimal)
   @instantiate(assert_not_equal, minimal)
   @instantiate(assert_less_than, minimal)
   @instantiate(assert_less_than_or_equal, minimal)
   @instantiate(assert_greater_than, minimal)
   @instantiate(assert_greater_than_or_equal, minimal)
   
end module pf_AssertReal_{rank}d_mod


   

