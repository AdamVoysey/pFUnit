@tkr_parameters all
[(integer, default, 0)]
[(integer, 32, 0)]
[(integer, 64, 0)]
[(real, default, 0)]
[(real, double, 0)]
[(real, 32, 0)]
[(real, 64, 0)]
[(real, 128, 0)]
[(complex, default, 0)]
[(complex, double, 0)]
[(complex, 32, 0)]
[(complex, 64, 0)]
[(complex, 128, 0)]
@end tkr_parameters

@template(MatcherAssert,[case])

module pf_{name}_mod
   use pf_AbstractMatcher_mod
   use pf_SourceLocation_mod
   use funit, only: throw
   implicit none
   private

   public :: assert_that
   
   interface assert_that
      module procedure :: assert_that_no_reason
      module procedure :: assert_that_reason
   end interface assert_that

contains

   subroutine assert_that_no_reason(actual, matcher, location)
      class(*), intent(in) :: actual
      class(AbstractMatcher{mangle}), intent(in) :: matcher
      type (SourceLocation), optional, intent(in) :: location

      call assert_that('', actual, matcher, location=location)
      
   end subroutine assert_that_no_reason
 

   subroutine assert_that_reason(reason, actual, matcher, location)
      use pf_StringDescription_mod
      character(*), intent(in) :: reason
      class(*), intent(in) :: actual
      class(AbstractMatcher{mangle}), intent(in) :: matcher
      type (SourceLocation), optional, intent(in) :: location

      type (StringDescription) :: description

      if (.not. matcher%matches(actual)) then
         description = StringDescription()
         call description%append_text(reason)
         call description%append_text(new_line('a')//'Expected: ')
         call description%append_description_of(matcher)
         call description%append_text(new_line('a')//'     but: ')
         call matcher%describe_mismatch(actual, description)
         call throw(description%to_string(), location)
      end if
      
   end subroutine assert_that_reason
 
end module pf_{name}_mod
@end template

@template(uses,[case])
   use pf_MatcherAssert{mangle}_mod
@end template

@instantiate(MatcherAssert, all)

module pf_MatcherAssert_string_mod
   use pf_AbstractMatcher_mod
   use pf_SourceLocation_mod
   use funit, only: throw
   implicit none
   private

   public :: assert_that
   
   interface assert_that
      module procedure :: assert_that_no_reason
      module procedure :: assert_that_reason
   end interface assert_that

contains

   subroutine assert_that_no_reason(actual, matcher, location)
      class(*), intent(in) :: actual
      class(AbstractMatcher_string), intent(in) :: matcher
      type (SourceLocation), optional, intent(in) :: location

      call assert_that('', actual, matcher, location=location)
      
   end subroutine assert_that_no_reason
 

   subroutine assert_that_reason(reason, actual, matcher, location)
      use pf_StringDescription_mod
      character(*), intent(in) :: reason
      class(*), intent(in) :: actual
      class(AbstractMatcher_string), intent(in) :: matcher
      type (SourceLocation), optional, intent(in) :: location

      type (StringDescription) :: description

      if (.not. matcher%matches(actual)) then
         description = StringDescription()
         call description%append_text(reason)
         call description%append_text(new_line('a')//'Expected: ')
         call description%append_description_of(matcher)
         call description%append_text(new_line('a')//'     but: ')
         call matcher%describe_mismatch(actual, description)
         call throw(description%to_string(), location)
      end if
      
   end subroutine assert_that_reason
 
end module pf_MatcherAssert_string_mod

module pf_MatcherAssert_mod
  @instantiate(uses, all)
  use pf_MatcherAssert_string_mod
end module pf_MatcherAssert_mod
 
   

