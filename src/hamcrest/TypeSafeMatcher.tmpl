@tkr_parameters all
[(integer, default, 0)]
[(integer, 32, 0)]
[(integer, 64, 0)]
[(real, default, 0)]
[(real, double, 0)]
[(real, 32, 0)]
[(real, 64, 0)]
[(real, 128, 0)]
[(complex, default, 0)]
[(complex, double, 0)]
[(complex, 32, 0)]
[(complex, 64, 0)]
[(complex, 128, 0)]
@end tkr_parameters

@template(TypeSafeMatcher,[case])

module pf_{name}_mod
  use pf_AbstractMatcher_mod
  use pf_MatcherDescription_mod, only: MatcherDescription
  use iso_fortran_env
  implicit none
  private

  public :: {name}

  type, abstract, extends(AbstractMatcher) :: {name}
   contains
     procedure :: matches
     procedure(matches_safely), deferred :: matches_safely
     procedure :: describe_mismatch
     procedure(describe_mismatch_safely), deferred :: describe_mismatch_safely
  end type {name}

  abstract interface

     logical function matches_safely(this, item)
       use iso_fortran_env
       import MatcherDescription
       import {name}
       class({name}), intent(in) :: this
       type({case.type}(kind={case.kind})), intent(in) :: item
     end function matches_safely

     subroutine describe_mismatch_safely(this, item, description)
       use iso_fortran_env
       import MatcherDescription
       import {name}
       class({name}), intent(in) :: this
       type({case.type}(kind={case.kind})), intent(in) :: item
       class(MatcherDescription), intent(inout) :: description
     end subroutine describe_mismatch_safely

  end interface


contains


  logical function matches(this, actual_value)
    class({name}), intent(in) :: this
    class(*), intent(in) :: actual_value

    select type(actual_value)
    type is ({case.type}(kind={case.kind}))
       matches = this%matches_safely(actual_value)
    class default
       matches = .false.
    end select

  end function matches
  
  subroutine describe_mismatch(this, actual, description)
    class({name}), intent(in) :: this
    class(*), intent(in) :: actual
    class(MatcherDescription), intent(inout) :: description

    select type (actual)
    type is ({case.type}(kind={case.kind}))
       call this%describe_mismatch_safely(actual, description)
    class default
       call description%append_text("was not a ")
       call description%append_text("type({case.type}(kind={case.kind}))")
    end select
       
  end subroutine describe_mismatch
  
end module pf_{name}_mod


@template(uses,[case])
   use pf_TypeSafeMatcher{mangle}_mod
@end template


module pf_TypeSafeMatcher_String_mod
  use pf_AbstractMatcher_mod
  use pf_MatcherDescription_mod, only: MatcherDescription
  use iso_fortran_env
  implicit none
  private

  public :: TypeSafeMatcher_String

  type, abstract, extends(AbstractMatcher) :: TypeSafeMatcher_String
   contains
     procedure :: matches
     procedure(matches_safely), deferred :: matches_safely
     procedure :: describe_mismatch
     procedure(describe_mismatch_safely), deferred :: describe_mismatch_safely
  end type TypeSafeMatcher_String

  abstract interface

     logical function matches_safely(this, item)
       use iso_fortran_env
       import MatcherDescription
       import TypeSafeMatcher_String
       class(TypeSafeMatcher_String), intent(in) :: this
       character(*), intent(in) :: item
     end function matches_safely

     subroutine describe_mismatch_safely(this, item, description)
       use iso_fortran_env
       import MatcherDescription
       import TypeSafeMatcher_String
       class(TypeSafeMatcher_String), intent(in) :: this
       character(*), intent(in) :: item
       class(MatcherDescription), intent(inout) :: description
     end subroutine describe_mismatch_safely

  end interface


contains


  logical function matches(this, actual_value)
    class(TypeSafeMatcher_String), intent(in) :: this
    class(*), intent(in) :: actual_value

    select type(actual_value)
    type is (character(*))
       matches = this%matches_safely(actual_value)
    class default
       matches = .false.
    end select

  end function matches
  
  subroutine describe_mismatch(this, actual, description)
    class(TypeSafeMatcher_String), intent(in) :: this
    class(*), intent(in) :: actual
    class(MatcherDescription), intent(inout) :: description

    select type (actual)
    type is (character(*))
       call this%describe_mismatch_safely(actual, description)
    class default
       call description%append_text("was not a ")
       call description%append_text("type({case.type}(kind={case.kind}))")
    end select
       
  end subroutine describe_mismatch
  
end module pf_TypeSafeMatcher_String_mod



@instantiate(TypeSafeMatcher, all)

module pf_TypeSafeMatcher_mod
  @instantiate(uses, all)
  use pf_TypeSafeMatcher_String_mod
end module pf_TypeSafeMatcher_mod
