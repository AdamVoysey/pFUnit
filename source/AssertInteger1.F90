

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!  This file 'AssertInteger1.F90' is automatically generated by
!  'GenerateRealArrayNewSignature.py'.  Changes made here will be
!  overwritten the next time that script is run.
!
!  2013-0722 MLR Michael.L.Rilee-1@nasa.gov
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module AssertInteger1_mod

   use Params_mod
   use AssertBasic_mod
   use Exception_mod
   use SourceLocation_mod
!   use ThrowFundamentalTypes_mod, only : throwNonConformable
   use StringUtilities_mod


   implicit none
   private


   public :: assertEqual


   integer, parameter :: L_INFINITY_NORM = 0
   integer, parameter :: L1_NORM         = 1
   integer, parameter :: L2_NORM         = 2

   integer, parameter :: MAXLEN_SHAPE = 80


interface vectorNorm

   module procedure vectorNorm_0D_real32
   module procedure vectorNorm_0D_real64
   module procedure vectorNorm_1D_real32
   module procedure vectorNorm_1D_real64
   module procedure vectorNorm_2D_real32
   module procedure vectorNorm_2D_real64
   module procedure vectorNorm_3D_real32
   module procedure vectorNorm_3D_real64
   module procedure vectorNorm_4D_real32
   module procedure vectorNorm_4D_real64
   module procedure vectorNorm_5D_real32
   module procedure vectorNorm_5D_real64
   module procedure vectorNorm_0D_complex32
   module procedure vectorNorm_0D_complex64
   module procedure vectorNorm_1D_complex32
   module procedure vectorNorm_1D_complex64
   module procedure vectorNorm_2D_complex32
   module procedure vectorNorm_2D_complex64
   module procedure vectorNorm_3D_complex32
   module procedure vectorNorm_3D_complex64
   module procedure vectorNorm_4D_complex32
   module procedure vectorNorm_4D_complex64
   module procedure vectorNorm_5D_complex32
   module procedure vectorNorm_5D_complex64
   module procedure vectorNorm_0D_integerdefault
   module procedure vectorNorm_1D_integerdefault
   module procedure vectorNorm_2D_integerdefault
   module procedure vectorNorm_3D_integerdefault
   module procedure vectorNorm_4D_integerdefault
   module procedure vectorNorm_5D_integerdefault

end interface vectorNorm


interface isWithinTolerance

   module procedure isWithinTolerance_0D_real32
   module procedure isWithinTolerance_0D_real64
   module procedure isWithinTolerance_1D_real32
   module procedure isWithinTolerance_1D_real64
   module procedure isWithinTolerance_2D_real32
   module procedure isWithinTolerance_2D_real64
   module procedure isWithinTolerance_3D_real32
   module procedure isWithinTolerance_3D_real64
   module procedure isWithinTolerance_4D_real32
   module procedure isWithinTolerance_4D_real64
   module procedure isWithinTolerance_5D_real32
   module procedure isWithinTolerance_5D_real64
   module procedure isWithinTolerance_0D_complex32
   module procedure isWithinTolerance_0D_complex64
   module procedure isWithinTolerance_1D_complex32
   module procedure isWithinTolerance_1D_complex64
   module procedure isWithinTolerance_2D_complex32
   module procedure isWithinTolerance_2D_complex64
   module procedure isWithinTolerance_3D_complex32
   module procedure isWithinTolerance_3D_complex64
   module procedure isWithinTolerance_4D_complex32
   module procedure isWithinTolerance_4D_complex64
   module procedure isWithinTolerance_5D_complex32
   module procedure isWithinTolerance_5D_complex64
   module procedure isWithinTolerance_0D_integerdefault
   module procedure isWithinTolerance_1D_integerdefault
   module procedure isWithinTolerance_2D_integerdefault
   module procedure isWithinTolerance_3D_integerdefault
   module procedure isWithinTolerance_4D_integerdefault
   module procedure isWithinTolerance_5D_integerdefault

end interface isWithinTolerance


interface assertEqual

   module procedure assertEqual_int_0D_r32_0D_tol32
   module procedure assertEqual_int_0D_r32_0D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_0D_tol32
   module procedure assertEqual_r32_0D_r32_0D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_0D_tol64
   module procedure assertEqual_int_0D_r64_0D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_0D_tol64
   module procedure assertEqual_r32_0D_r64_0D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_0D_tol64
   module procedure assertEqual_r64_0D_r64_0D_tol64_WithoutTolerance
   module procedure assertEqual_int_0D_r32_1D_tol32
   module procedure assertEqual_int_0D_r32_1D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_1D_tol32
   module procedure assertEqual_r32_0D_r32_1D_tol32_WithoutTolerance
   module procedure assertEqual_int_1D_r32_1D_tol32
   module procedure assertEqual_int_1D_r32_1D_tol32_WithoutTolerance
   module procedure assertEqual_r32_1D_r32_1D_tol32
   module procedure assertEqual_r32_1D_r32_1D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_1D_tol64
   module procedure assertEqual_int_0D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_1D_tol64
   module procedure assertEqual_r32_0D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_1D_tol64
   module procedure assertEqual_r64_0D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_int_1D_r64_1D_tol64
   module procedure assertEqual_int_1D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_r32_1D_r64_1D_tol64
   module procedure assertEqual_r32_1D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_r64_1D_r64_1D_tol64
   module procedure assertEqual_r64_1D_r64_1D_tol64_WithoutTolerance
   module procedure assertEqual_int_0D_r32_2D_tol32
   module procedure assertEqual_int_0D_r32_2D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_2D_tol32
   module procedure assertEqual_r32_0D_r32_2D_tol32_WithoutTolerance
   module procedure assertEqual_int_2D_r32_2D_tol32
   module procedure assertEqual_int_2D_r32_2D_tol32_WithoutTolerance
   module procedure assertEqual_r32_2D_r32_2D_tol32
   module procedure assertEqual_r32_2D_r32_2D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_2D_tol64
   module procedure assertEqual_int_0D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_2D_tol64
   module procedure assertEqual_r32_0D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_2D_tol64
   module procedure assertEqual_r64_0D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_int_2D_r64_2D_tol64
   module procedure assertEqual_int_2D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_r32_2D_r64_2D_tol64
   module procedure assertEqual_r32_2D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_r64_2D_r64_2D_tol64
   module procedure assertEqual_r64_2D_r64_2D_tol64_WithoutTolerance
   module procedure assertEqual_int_0D_r32_3D_tol32
   module procedure assertEqual_int_0D_r32_3D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_3D_tol32
   module procedure assertEqual_r32_0D_r32_3D_tol32_WithoutTolerance
   module procedure assertEqual_int_3D_r32_3D_tol32
   module procedure assertEqual_int_3D_r32_3D_tol32_WithoutTolerance
   module procedure assertEqual_r32_3D_r32_3D_tol32
   module procedure assertEqual_r32_3D_r32_3D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_3D_tol64
   module procedure assertEqual_int_0D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_3D_tol64
   module procedure assertEqual_r32_0D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_3D_tol64
   module procedure assertEqual_r64_0D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_int_3D_r64_3D_tol64
   module procedure assertEqual_int_3D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_r32_3D_r64_3D_tol64
   module procedure assertEqual_r32_3D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_r64_3D_r64_3D_tol64
   module procedure assertEqual_r64_3D_r64_3D_tol64_WithoutTolerance
   module procedure assertEqual_int_0D_r32_4D_tol32
   module procedure assertEqual_int_0D_r32_4D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_4D_tol32
   module procedure assertEqual_r32_0D_r32_4D_tol32_WithoutTolerance
   module procedure assertEqual_int_4D_r32_4D_tol32
   module procedure assertEqual_int_4D_r32_4D_tol32_WithoutTolerance
   module procedure assertEqual_r32_4D_r32_4D_tol32
   module procedure assertEqual_r32_4D_r32_4D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_4D_tol64
   module procedure assertEqual_int_0D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_4D_tol64
   module procedure assertEqual_r32_0D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_4D_tol64
   module procedure assertEqual_r64_0D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_int_4D_r64_4D_tol64
   module procedure assertEqual_int_4D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_r32_4D_r64_4D_tol64
   module procedure assertEqual_r32_4D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_r64_4D_r64_4D_tol64
   module procedure assertEqual_r64_4D_r64_4D_tol64_WithoutTolerance
   module procedure assertEqual_int_0D_r32_5D_tol32
   module procedure assertEqual_int_0D_r32_5D_tol32_WithoutTolerance
   module procedure assertEqual_r32_0D_r32_5D_tol32
   module procedure assertEqual_r32_0D_r32_5D_tol32_WithoutTolerance
   module procedure assertEqual_int_5D_r32_5D_tol32
   module procedure assertEqual_int_5D_r32_5D_tol32_WithoutTolerance
   module procedure assertEqual_r32_5D_r32_5D_tol32
   module procedure assertEqual_r32_5D_r32_5D_tol32_WithoutTolerance
   module procedure assertEqual_int_0D_r64_5D_tol64
   module procedure assertEqual_int_0D_r64_5D_tol64_WithoutTolerance
   module procedure assertEqual_r32_0D_r64_5D_tol64
   module procedure assertEqual_r32_0D_r64_5D_tol64_WithoutTolerance
   module procedure assertEqual_r64_0D_r64_5D_tol64
   module procedure assertEqual_r64_0D_r64_5D_tol64_WithoutTolerance
   module procedure assertEqual_int_5D_r64_5D_tol64
   module procedure assertEqual_int_5D_r64_5D_tol64_WithoutTolerance
   module procedure assertEqual_r32_5D_r64_5D_tol64
   module procedure assertEqual_r32_5D_r64_5D_tol64_WithoutTolerance
   module procedure assertEqual_r64_5D_r64_5D_tol64
   module procedure assertEqual_r64_5D_r64_5D_tol64_WithoutTolerance

end interface assertEqual


interface differenceReport

   module procedure differenceReport_integerdefault64
   module procedure differenceReport_real3232
   module procedure differenceReport_real3264
   module procedure differenceReport_real6432
   module procedure differenceReport_real6464
   module procedure differenceReport_complex3232
   module procedure differenceReport_complex3264
   module procedure differenceReport_complex6432
   module procedure differenceReport_complex6464

end interface differenceReport


interface valuesReport

   module procedure valuesReport_integerintegerdefaultdefault
   module procedure valuesReport_integerrealdefault32
   module procedure valuesReport_integerrealdefault64
   module procedure valuesReport_realreal3232
   module procedure valuesReport_realreal3264
   module procedure valuesReport_realreal6464
   module procedure valuesReport_integercomplexdefault32
   module procedure valuesReport_integercomplexdefault64
   module procedure valuesReport_realcomplex3232
   module procedure valuesReport_realcomplex3264
   module procedure valuesReport_realcomplex6464
   module procedure valuesReport_complexcomplex3232
   module procedure valuesReport_complexcomplex3264
   module procedure valuesReport_complexcomplex6464

end interface valuesReport


interface assertEqual_internal

   module procedure assertEqual_e0_integerdefault_f0_integerdefault_tol64_
   module procedure assertEqual_e1_integerdefault_f0_integerdefault_tol64_
   module procedure assertEqual_e0_integerdefault_f1_integerdefault_tol64_
   module procedure assertEqual_e1_integerdefault_f1_integerdefault_tol64_
   module procedure assertEqual_e0_integerdefault_f0_real32_tol32_
   module procedure assertEqual_e1_integerdefault_f0_real32_tol32_
   module procedure assertEqual_e0_integerdefault_f1_real32_tol32_
   module procedure assertEqual_e1_integerdefault_f1_real32_tol32_
   module procedure assertEqual_e0_integerdefault_f0_real64_tol64_
   module procedure assertEqual_e1_integerdefault_f0_real64_tol64_
   module procedure assertEqual_e0_integerdefault_f1_real64_tol64_
   module procedure assertEqual_e1_integerdefault_f1_real64_tol64_
   module procedure assertEqual_e0_real32_f0_real32_tol32_
   module procedure assertEqual_e1_real32_f0_real32_tol32_
   module procedure assertEqual_e0_real32_f1_real32_tol32_
   module procedure assertEqual_e1_real32_f1_real32_tol32_
   module procedure assertEqual_e0_real32_f0_real64_tol64_
   module procedure assertEqual_e1_real32_f0_real64_tol64_
   module procedure assertEqual_e0_real32_f1_real64_tol64_
   module procedure assertEqual_e1_real32_f1_real64_tol64_
   module procedure assertEqual_e0_real64_f0_real64_tol64_
   module procedure assertEqual_e1_real64_f0_real64_tol64_
   module procedure assertEqual_e0_real64_f1_real64_tol64_
   module procedure assertEqual_e1_real64_f1_real64_tol64_
   module procedure assertEqual_e0_integerdefault_f0_complex32_tol32_
   module procedure assertEqual_e1_integerdefault_f0_complex32_tol32_
   module procedure assertEqual_e0_integerdefault_f1_complex32_tol32_
   module procedure assertEqual_e1_integerdefault_f1_complex32_tol32_
   module procedure assertEqual_e0_integerdefault_f0_complex64_tol64_
   module procedure assertEqual_e1_integerdefault_f0_complex64_tol64_
   module procedure assertEqual_e0_integerdefault_f1_complex64_tol64_
   module procedure assertEqual_e1_integerdefault_f1_complex64_tol64_
   module procedure assertEqual_e0_real32_f0_complex32_tol32_
   module procedure assertEqual_e1_real32_f0_complex32_tol32_
   module procedure assertEqual_e0_real32_f1_complex32_tol32_
   module procedure assertEqual_e1_real32_f1_complex32_tol32_
   module procedure assertEqual_e0_real32_f0_complex64_tol64_
   module procedure assertEqual_e1_real32_f0_complex64_tol64_
   module procedure assertEqual_e0_real32_f1_complex64_tol64_
   module procedure assertEqual_e1_real32_f1_complex64_tol64_
   module procedure assertEqual_e0_real64_f0_complex64_tol64_
   module procedure assertEqual_e1_real64_f0_complex64_tol64_
   module procedure assertEqual_e0_real64_f1_complex64_tol64_
   module procedure assertEqual_e1_real64_f1_complex64_tol64_
   module procedure assertEqual_e0_complex32_f0_complex32_tol32_
   module procedure assertEqual_e1_complex32_f0_complex32_tol32_
   module procedure assertEqual_e0_complex32_f1_complex32_tol32_
   module procedure assertEqual_e1_complex32_f1_complex32_tol32_
   module procedure assertEqual_e0_complex32_f0_complex64_tol64_
   module procedure assertEqual_e1_complex32_f0_complex64_tol64_
   module procedure assertEqual_e0_complex32_f1_complex64_tol64_
   module procedure assertEqual_e1_complex32_f1_complex64_tol64_
   module procedure assertEqual_e0_complex64_f0_complex64_tol64_
   module procedure assertEqual_e1_complex64_f0_complex64_tol64_
   module procedure assertEqual_e0_complex64_f1_complex64_tol64_
   module procedure assertEqual_e1_complex64_f1_complex64_tol64_

end interface assertEqual_internal

contains
! interface vectorNorm implementations

  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x
    integer :: norm
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x
    integer :: norm
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_1D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_1D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_2D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_2D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_3D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_3D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_4D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_4D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_real32(x, norm) result(y)
    real(kind=r32), intent(in) :: x(:,:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_5D_real32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_real64(x, norm) result(y)
    real(kind=r64), intent(in) :: x(:,:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(sum(x*x))
    end select

  end function vectorNorm_5D_real64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x
    integer :: norm
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x
    integer :: norm
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_1D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_1D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_2D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_2D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_3D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_3D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_4D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_4D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_complex32(x, norm) result(y)
    complex(kind=r32), intent(in) :: x(:,:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_5D_complex32

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_complex64(x, norm) result(y)
    complex(kind=r64), intent(in) :: x(:,:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*conjg(x)))
       y = sqrt(sum(x*conjg(x)))
    end select

  end function vectorNorm_5D_complex64

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 0.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_0D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x
    integer :: norm
    real (kind=r64) :: y

    y = abs(x) ! independent of norm for rank=0 (scalar) case.

  end function vectorNorm_0D_integerdefault

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 1.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_1D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x(:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_1D_integerdefault

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 2.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_2D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x(:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_2D_integerdefault

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 3.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_3D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x(:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_3D_integerdefault

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 4.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_4D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x(:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_4D_integerdefault

   
  !---------------------------------------------------------------------------
  !> Returns the independent of norm in vector by the given diminsional
  !! double-precission real numbers and given integer norm
  !!
  !! The following is for rank = 5.
  !!
  !! @param x - given dimensional double-precision real numbers
  !! @param norm - given norm
  !!
  !! @return independent of norm
  !---------------------------------------------------------------------------
  function vectorNorm_5D_integerdefault(x, norm) result(y)
    integer, intent(in) :: x(:,:,:,:,:)
    integer :: norm
    real (kind=r64) :: y

! Note that abs(complex) is like the L2_NORM unless care is taken *here*.  Fix later...
    select case (norm)  ! code to support rank /= 0 cases.
    case (L_INFINITY_NORM)
       y = maxval(abs(x))
    case (L1_NORM)
       y = sum(abs(x))
    case (L2_NORM)
!       y = sqrt(sum(x**2))
!       y = sqrt(sum(x*conjg(x)))
!       y = sqrt(sum(x*x))
       y = sqrt(real(sum(x*x),kind=r64))
    end select

  end function vectorNorm_5D_integerdefault

! end interface vectorNorm implementations
! interface isWithinTolerance implementations

   logical function isWithinTolerance_0D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x
     real(kind=r32), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_real32

   
   logical function isWithinTolerance_0D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x
     real(kind=r64), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_real64

   
   logical function isWithinTolerance_1D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:)
     real(kind=r32), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_real32

   
   logical function isWithinTolerance_1D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:)
     real(kind=r64), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_real64

   
   logical function isWithinTolerance_2D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:)
     real(kind=r32), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_real32

   
   logical function isWithinTolerance_2D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:)
     real(kind=r64), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_real64

   
   logical function isWithinTolerance_3D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_real32

   
   logical function isWithinTolerance_3D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_real64

   
   logical function isWithinTolerance_4D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_real32

   
   logical function isWithinTolerance_4D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_real64

   
   logical function isWithinTolerance_5D_real32(x, tolerance, norm)
!     real (kind=r32), intent(in) :: x(:,:,:,:,:)
     real(kind=r32), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_real32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_real32

   
   logical function isWithinTolerance_5D_real64(x, tolerance, norm)
!     real (kind=r64), intent(in) :: x(:,:,:,:,:)
     real(kind=r64), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_real64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_real64

   
   logical function isWithinTolerance_0D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x
     complex(kind=c32), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_complex32

   
   logical function isWithinTolerance_0D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x
     complex(kind=c64), intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_complex64

   
   logical function isWithinTolerance_1D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:)
     complex(kind=c32), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_complex32

   
   logical function isWithinTolerance_1D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:)
     complex(kind=c64), intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_complex64

   
   logical function isWithinTolerance_2D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:)
     complex(kind=c32), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_complex32

   
   logical function isWithinTolerance_2D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:)
     complex(kind=c64), intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_complex64

   
   logical function isWithinTolerance_3D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_complex32

   
   logical function isWithinTolerance_3D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_complex64

   
   logical function isWithinTolerance_4D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_complex32

   
   logical function isWithinTolerance_4D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_complex64

   
   logical function isWithinTolerance_5D_complex32(x, tolerance, norm)
!     complex (kind=r32), intent(in) :: x(:,:,:,:,:)
     complex(kind=c32), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_complex32 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_complex32

   
   logical function isWithinTolerance_5D_complex64(x, tolerance, norm)
!     complex (kind=r64), intent(in) :: x(:,:,:,:,:)
     complex(kind=c64), intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_complex64 = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_complex64

   
   logical function isWithinTolerance_0D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x
     integer, intent(in) :: x
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_0D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_0D_integerdefault

   
   logical function isWithinTolerance_1D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x(:)
     integer, intent(in) :: x(:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_1D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_1D_integerdefault

   
   logical function isWithinTolerance_2D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x(:,:)
     integer, intent(in) :: x(:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_2D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_2D_integerdefault

   
   logical function isWithinTolerance_3D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x(:,:,:)
     integer, intent(in) :: x(:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_3D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_3D_integerdefault

   
   logical function isWithinTolerance_4D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x(:,:,:,:)
     integer, intent(in) :: x(:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_4D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_4D_integerdefault

   
   logical function isWithinTolerance_5D_integerdefault(x, tolerance, norm)
!     integer (kind=rdefault), intent(in) :: x(:,:,:,:,:)
     integer, intent(in) :: x(:,:,:,:,:)
     real (kind=r64), intent(in) :: tolerance
     integer,         intent(in) :: norm

     isWithinTolerance_5D_integerdefault = ( vectorNorm(x, norm) <= tolerance )

   end function isWithinTolerance_5D_integerdefault

! end interface isWithinTolerance implementations
! interface assertEqual implementations

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_0D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f0_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_0D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_0D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_0D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f0_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_0D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_0D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_0D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f0_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_0D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_0D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_0D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f0_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_0D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_0D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_0D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f0_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_0D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_0D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_1D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_1D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_1D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_1D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_1D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_1D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_1D_r32_1D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:)
     real(kind=r32), intent(in) :: found(:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_1D_r32_1D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:)
     real(kind=r32), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_1D_r32_1D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_1D_r32_1D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:)
     real(kind=r32), intent(in) :: found(:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_1D_r32_1D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:)
     real(kind=r32), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_1D_r32_1D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_1D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_1D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_1D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_1D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_1D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_1D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_1D_r64_1D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_1D_r64_1D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:)
     real(kind=r64), intent(in) :: found(:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_1D_r64_1D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_2D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_2D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_2D_r32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_2D_r32_2D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_2D_r32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_r32_2D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_r32_2D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     real(kind=r32), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_2D_r32_2D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_2D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_2D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_2D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_2D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_2D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_2D_r64_2D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_2D_r64_2D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:)
     real(kind=r64), intent(in) :: found(:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_2D_r64_2D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_3D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_3D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_3D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_3D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_3D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_3D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_3D_r32_3D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_3D_r32_3D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_3D_r32_3D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_3D_r32_3D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_3D_r32_3D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_3D_r32_3D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_3D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_3D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_3D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_3D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_3D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_3D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_3D_r64_3D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_3D_r64_3D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_3D_r64_3D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_4D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_4D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_4D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_4D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_4D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_4D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_4D_r32_4D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_4D_r32_4D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_4D_r32_4D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_4D_r32_4D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_4D_r32_4D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_4D_r32_4D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_4D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_4D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_4D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_4D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_4D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_4D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_4D_r64_4D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_4D_r64_4D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_4D_r64_4D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_5D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r32_5D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r32_5D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_5D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r32_5D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r32), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r32_5D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_5D_r32_5D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_5D_r32_5D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_5D_r32_5D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_5D_r32_5D_tol32( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:,:)
     real(kind=r32), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r32)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real32_tol32_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_5D_r32_5D_tol32_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:,:)
     real(kind=r32), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_5D_r32_5D_tol32(&
   &   expected, found, &
   &   tolerance=real(0., kind=r32), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_0D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_0D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_0D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_0D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e0_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_0D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_0D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_5D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     integer, intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_integerdefault_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_int_5D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     integer, intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_int_5D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_5D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real32_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r32_5D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r32), intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r32_5D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

   
  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_5D_r64_5D_tol64( &
   &  expected, found, tolerance, message, location )
! was tolerance, message -- need to propagate changes... e.g. to test files
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)
     real(kind=r64), intent(in) :: tolerance
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     real(kind=kind(tolerance)) :: tolerance_
     character(len=:), allocatable :: message_
     type (SourceLocation) :: location_

! Tolerance is now not optional.
!     if(present(tolerance)) then
        tolerance_ = tolerance
!     else
!        tolerance_ = real(0., kind=r64)
!     end if

     if(present(location)) then 
        location_ = location
     else
        location_ = UNKNOWN_SOURCE_LOCATION
     end if

     if(present(message)) then
        message_ = message
     else
        message_ = NULL_MESSAGE
     end if

    call assertSameShape(shape(expected),shape(found), location=location_)
    if (anyExceptions()) return

! Next allow call to here...
!mlr-NextStep-Begin
     call assertEqual_e1_real64_f1_real64_tol64_(&
     &  expected, shape(expected), found, shape(found), &
     &  tolerance_, message_, location_, EQP )
!mlr-NextStep-End
     
   end subroutine

  !---------------------------------------------------------------------------
  !> Asserts that two real numbers are equal.  If they are not, an
  !! Exception is thrown with the given message.
  !!
  !! @param expected - expected real numbers
  !! @param found -  found real numbers
  !! @param message - the identifying message for the Exception
  !!
  !! @throw Exception - when two real numbers are not equal.
  !---------------------------------------------------------------------------

   subroutine assertEqual_r64_5D_r64_5D_tol64_WithoutTolerance( &
   &  expected, found, message, location )
     implicit none
     real(kind=r64), intent(in) :: expected(:,:,:,:,:)
     real(kind=r64), intent(in) :: found(:,:,:,:,:)

!     character(len=*), intent(in) :: message  ! not used yet!
     character(len=*), optional, intent(in) :: message  ! not used yet!
     type (SourceLocation), optional, intent(in) :: location

     call assertEqual_r64_5D_r64_5D_tol64(&
   &   expected, found, &
   &   tolerance=real(0., kind=r64), &
   &   message=message, location=location )
     
   end subroutine

! end interface assertEqual implementations
! interface differenceReport implementations

    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_integerdefault64(difference, tolerance) result(differenceReport)
      integer, intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real3232(difference, tolerance) result(differenceReport)
     real(kind=r32), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real3264(difference, tolerance) result(differenceReport)
     real(kind=r32), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real6432(difference, tolerance) result(differenceReport)
     real(kind=r64), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_real6464(difference, tolerance) result(differenceReport)
     real(kind=r64), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(real(difference,kind=r32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex3232(difference, tolerance) result(differenceReport)
     complex(kind=r32), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex3264(difference, tolerance) result(differenceReport)
     complex(kind=r32), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex6432(difference, tolerance) result(differenceReport)
     complex(kind=r64), intent(in) :: difference
     real(kind=r32), intent(in) :: tolerance
!     real(kind=r32), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

   
    character(len=MAXLEN_MESSAGE) &
    & function differenceReport_complex6464(difference, tolerance) result(differenceReport)
     complex(kind=r64), intent(in) :: difference
     real(kind=r64), intent(in) :: tolerance
!     real(kind=r64), optional, intent(in) :: tolerance
      differenceReport = '    difference: |' // trim(toString(cmplx(difference,kind=c32))) // &
      & '| > tolerance:' // trim(toString(tolerance))
    end function 

! end interface differenceReport implementations
! interface valuesReport implementations

      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerintegerdefaultdefault &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer, intent(in) :: expected
        integer, intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerrealdefault32 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer, intent(in) :: expected
        real(kind=r32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integerrealdefault64 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer, intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        real(kind=r32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realreal6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        real(kind=r64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(real(expected,kind=r32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(real(found,kind=r32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplexdefault32 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer, intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_integercomplexdefault64 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        integer, intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r32), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_realcomplex6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        real(kind=r64), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex3232 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c32), intent(in) :: expected
        complex(kind=c32), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex3264 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c32), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

   
      character(len=MAXLEN_MESSAGE) &
      & function valuesReport_complexcomplex6464 &
      & (expected,found,ePrefix,ePostfix,fPrefix,fPostfix) &
      & result(valuesReport)
        complex(kind=c64), intent(in) :: expected
        complex(kind=c64), intent(in) :: found
        character(len=*), optional, intent(in) :: &
      &   ePrefix, ePostfix, fPrefix, fPostfix
        character(len=MAXLEN_MESSAGE) :: &
      &   ePrefix_, ePostfix_, fPrefix_, fPostfix_

      if( .not.present(ePrefix) ) then
         ePrefix_ = 'expected:'
      else
         ePrefix_ = ePrefix
      end if
      if( .not.present(ePostfix) ) then
         ePostfix_ = ''
      else
         ePostfix_ = ePostfix
      end if
      if( .not.present(fPrefix) ) then
         fPrefix_ = 'but found:'
      else
         fPrefix_ = fPrefix
      end if
      if( .not.present(fPostfix) ) then
         fPostfix_ = ''
      else
         fPostfix_ = fPostfix
      end if

! Note: removed '<.>'
        valuesReport = &
      & trim(ePrefix_)//' '// trim(toString(cmplx(expected,kind=c32))) // &
      & trim(ePostfix_)//' '// &
      & trim(fPrefix_)//' '//trim(toString(cmplx(found,kind=c32))) // &
      & trim(fPostfix_)// &
      & ''
      
      end function

! end interface valuesReport implementations
! interface assertEqual_internal implementations

    subroutine assertEqual_e0_integerdefault_f0_integerdefault_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    integer, intent(in) :: found
    integer :: found_
    integer :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f0_integerdefault_tol64_


   
    subroutine assertEqual_e1_integerdefault_f0_integerdefault_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    integer, intent(in) :: found
    integer :: found_
    integer :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f0_integerdefault_tol64_


   
    subroutine assertEqual_e0_integerdefault_f1_integerdefault_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    integer, dimension(product(fShape)), intent(in) :: found
    integer :: found_
    integer :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f1_integerdefault_tol64_


   
    subroutine assertEqual_e1_integerdefault_f1_integerdefault_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    integer, dimension(product(fShape)), intent(in) :: found
    integer :: found_
    integer :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f1_integerdefault_tol64_


   
    subroutine assertEqual_e0_integerdefault_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f0_real32_tol32_


   
    subroutine assertEqual_e1_integerdefault_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f0_real32_tol32_


   
    subroutine assertEqual_e0_integerdefault_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f1_real32_tol32_


   
    subroutine assertEqual_e1_integerdefault_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f1_real32_tol32_


   
    subroutine assertEqual_e0_integerdefault_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f0_real64_tol64_


   
    subroutine assertEqual_e1_integerdefault_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f0_real64_tol64_


   
    subroutine assertEqual_e0_integerdefault_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f1_real64_tol64_


   
    subroutine assertEqual_e1_integerdefault_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f1_real64_tol64_


   
    subroutine assertEqual_e0_real32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f0_real32_tol32_


   
    subroutine assertEqual_e1_real32_f0_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f0_real32_tol32_


   
    subroutine assertEqual_e0_real32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f1_real32_tol32_


   
    subroutine assertEqual_e1_real32_f1_real32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r32), dimension(product(fShape)), intent(in) :: found
    real(kind=r32) :: found_
    real(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f1_real32_tol32_


   
    subroutine assertEqual_e0_real32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f0_real64_tol64_


   
    subroutine assertEqual_e1_real32_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f0_real64_tol64_


   
    subroutine assertEqual_e0_real32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f1_real64_tol64_


   
    subroutine assertEqual_e1_real32_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f1_real64_tol64_


   
    subroutine assertEqual_e0_real64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real64_f0_real64_tol64_


   
    subroutine assertEqual_e1_real64_f0_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real64_f0_real64_tol64_


   
    subroutine assertEqual_e0_real64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real64_f1_real64_tol64_


   
    subroutine assertEqual_e1_real64_f1_real64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    real(kind=r64), dimension(product(fShape)), intent(in) :: found
    real(kind=r64) :: found_
    real(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = True

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (GTP)
              OK = delta1 .gt. 0
            case (GEP)
              OK = delta1 .ge. 0
            case (LTP)
              OK = delta1 .lt. 0
            case (LEP)
              OK = delta1 .le. 0 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (GTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (GEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be greater than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LTP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (LEP)
       call throw( &
       & trim(valuesReport(expected_,found_, &
       &   ePrefix='expected', &
       &   fPrefix='to be less than or equal to:')) // &       
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real64_f1_real64_tol64_


   
    subroutine assertEqual_e0_integerdefault_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f0_complex32_tol32_


   
    subroutine assertEqual_e1_integerdefault_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f0_complex32_tol32_


   
    subroutine assertEqual_e0_integerdefault_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f1_complex32_tol32_


   
    subroutine assertEqual_e1_integerdefault_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f1_complex32_tol32_


   
    subroutine assertEqual_e0_integerdefault_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f0_complex64_tol64_


   
    subroutine assertEqual_e1_integerdefault_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f0_complex64_tol64_


   
    subroutine assertEqual_e0_integerdefault_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, intent(in) :: expected
    integer :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_integerdefault_f1_complex64_tol64_


   
    subroutine assertEqual_e1_integerdefault_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    integer, dimension(product(eShape)), intent(in) :: expected
    integer :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_integerdefault_f1_complex64_tol64_


   
    subroutine assertEqual_e0_real32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f0_complex32_tol32_


   
    subroutine assertEqual_e1_real32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f0_complex32_tol32_


   
    subroutine assertEqual_e0_real32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f1_complex32_tol32_


   
    subroutine assertEqual_e1_real32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f1_complex32_tol32_


   
    subroutine assertEqual_e0_real32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f0_complex64_tol64_


   
    subroutine assertEqual_e1_real32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f0_complex64_tol64_


   
    subroutine assertEqual_e0_real32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real32_f1_complex64_tol64_


   
    subroutine assertEqual_e1_real32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r32), dimension(product(eShape)), intent(in) :: expected
    real(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real32_f1_complex64_tol64_


   
    subroutine assertEqual_e0_real64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real64_f0_complex64_tol64_


   
    subroutine assertEqual_e1_real64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real64_f0_complex64_tol64_


   
    subroutine assertEqual_e0_real64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_real64_f1_complex64_tol64_


   
    subroutine assertEqual_e1_real64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    real(kind=r64), dimension(product(eShape)), intent(in) :: expected
    real(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_real64_f1_complex64_tol64_


   
    subroutine assertEqual_e0_complex32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex32_f0_complex32_tol32_


   
    subroutine assertEqual_e1_complex32_f0_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex32_f0_complex32_tol32_


   
    subroutine assertEqual_e0_complex32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex32_f1_complex32_tol32_


   
    subroutine assertEqual_e1_complex32_f1_complex32_tol32_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r32), dimension(product(fShape)), intent(in) :: found
    complex(kind=r32) :: found_
    complex(kind=r32) :: delta1

    real(kind=r32), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex32_f1_complex32_tol32_


   
    subroutine assertEqual_e0_complex32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex32_f0_complex64_tol64_


   
    subroutine assertEqual_e1_complex32_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex32_f0_complex64_tol64_


   
    subroutine assertEqual_e0_complex32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex32_f1_complex64_tol64_


   
    subroutine assertEqual_e1_complex32_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r32), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r32) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex32_f1_complex64_tol64_


   
    subroutine assertEqual_e0_complex64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found )
       end do
    else
!         i = 1
         delta1 = expected-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex64_f0_complex64_tol64_


   
    subroutine assertEqual_e1_complex64_f0_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found )
       end do
    else
!         i = 1
         delta1 = expected(i)-found    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex64_f0_complex64_tol64_


   
    subroutine assertEqual_e0_complex64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e0_complex64_f1_complex64_tol64_


   
    subroutine assertEqual_e1_complex64_f1_complex64_tol64_( &
    & expected,eShape,found,fShape,tolerance,message,location, &
    & comparison )
    use Params_mod
    use Exception_mod
    use StringUtilities_mod
    use ThrowFundamentalTypes_mod, only : locationFormat
    implicit none
    integer, intent(in), dimension(:) :: eShape, fShape
    character(len=*), intent(in) :: message
    type (SourceLocation), intent(in) :: location
    integer, intent(in) :: comparison
    complex(kind=r64), dimension(product(eShape)), intent(in) :: expected
    complex(kind=r64) :: expected_
    complex(kind=r64), dimension(product(fShape)), intent(in) :: found
    complex(kind=r64) :: found_
    complex(kind=r64) :: delta1

    real(kind=r64), intent(in) :: tolerance

    
    real(kind=kind(tolerance)) :: tolerance_
!---    real(kind=kind(expected)) :: expected_
!---    real(kind=kind(found)) :: found_
    integer :: i,m,ir
    logical OK
    integer, dimension(size(fShape)) :: iLocation
    character(len=MAXLEN_SHAPE) :: locationInArray

! MLR: The following just might work...
    tolerance_ = tolerance

! fType != 'complex' = False

! Note:  Could assert size(expected) = size(found) and fShape = eShape...

!    print *,'0800 ',product(fShape),fShape
    m = product(fShape)
    i = 0
    OK = .true.
    
! Note:  Comparison occurs here.  Could use isWithinTolerance or other comparison function.
    if( m > 0 )then
       do while ( i < m .and. OK )
         i = i + 1

         delta1 = expected(i)-found(i)

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-1'
         end select
         
!         OK = .not. ( expected(i) /= found(i) )
!         OK = .not. ( expected(i) /= found(i) )
       end do
    else
!         i = 1
         delta1 = expected(i)-found(i)    

         select case (comparison)
            case (EQP)
              OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
            case (NEQP)
              OK = &
              &  .not. &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM ) 
            case (RELEQP)
              if ( abs(expected(i)) > 0 ) then
                 OK = &
              &  isWithinTolerance( &
              &    delta1 / expected(i), &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              else
                 OK = &
              &  isWithinTolerance( &
              &    delta1, &
              &    real(tolerance_,kind=r64), &
              &    L_INFINITY_NORM )
              end if
            case default
              print *,'select-error-2'
         end select

!         OK = &
!         &  isWithinTolerance( &
!         &    delta1, &
!         &    real(tolerance_,kind=r64), &
!         &    L_INFINITY_NORM )
         
!         OK = .not. ( expected(i) /= found(i) )
    end if

    if( .not. OK )then

    ! Save the FirstBad...
    expected_ = expected(i)
    found_    = found(i)

!    if( m > 0 )then
    if( size(fshape) > 0 ) then

    i = i - 1
    do ir = 1,size(fShape)
      iLocation(ir) = mod(i,fShape(ir)) + 1
      i = i / fShape(ir)
    end do

!    print *,'0998 ',m
!    print *,'0999 ',size(fShape)
!    print *,'1000 ',iLocation
    write(locationInArray,locationFormat(iLocation)) iLocation

    else

    write(locationInArray,*) '[1]'

    end if

! Scalar
! Note use of abs

    select case (comparison)
    case (EQP)
       call throw( &
       & trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case (NEQP)
       call throw( &
       & 'NOT '//trim(valuesReport(expected_,found_)) // &
       & '; '//trim(differenceReport(abs(found_ - expected_), tolerance_)) // &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       ) 
    case (RELEQP)    
       call throw( &
       & ';  first difference at element '//trim(locationInArray)//'.', &
       & location = location &
       )
    case default
       print *,'select-error-3'
    end select

    end if

    end subroutine assertEqual_e1_complex64_f1_complex64_tol64_


! end interface assertEqual_internal implementations
end module AssertInteger1_mod