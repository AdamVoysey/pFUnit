! Goal is not to exhaustively test all combinations, but rather at least
! one variant along each axis:

module newTest_AssertReal_mod
   use, intrinsic :: iso_fortran_env, only: REAL32, REAL64
   use pf_StringUtilities_mod
   use pf_SourceLocation_mod
   use pf_Exceptionlist_mod
   use FUnit, only: SourceLocation, throw, anyExceptions, AssertExceptionRaised
   use pf_AssertReal_0d_mod
   use pf_AssertReal_1d_mod
   use pf_AssertReal_2d_mod
   use pf_AssertReal_3d_mod
   use pf_AssertReal_4d_mod
   use pf_AssertReal_5d_mod
   implicit none
   
   @suite(name='AssertReal_suite')

   real(kind=REAL32), parameter :: good = 1
   real(kind=REAL32), parameter :: bad  = -999


contains

   ! Sanity check - verify that all combinations of optional arguments are allowed.
   @test
   subroutine test_equal_real_0d_real_0d_real_0d()
      @assertEqual(1.0, 1.0)
      @assertEqual(1.0, 1.0, tolerance=0.0)
      @assertEqual(1.0, 1.0, message='placeholder')
   end subroutine test_equal_real_0d_real_0d_real_0d

   ! Other shapes, dimensions
   @test
   subroutine test_equal_real_0d_real_1d_real_0d()

      @assertEqual(1.0, [1.0])
      @assertEqual(1.0, [1.0,1.0], tolerance=0.0)
      @assertEqual([1.0,1.0], [1.0,1.0], tolerance=0.0)
      @assertEqual(1.0, reshape([1.0],[1,1]))
      @assertEqual(reshape([1.0,2.0,3.0,3.0],[2,2]), reshape([1.0,2.0,3.0,3.0],[2,2]))

   end subroutine test_equal_real_0d_real_1d_real_0d
   
   ! Check that tolerance works
   @test
   subroutine test_equal_within_tolerance()
      @assertEqual(1.0, 1.09, tolerance=0.1)
      @assertEqual(1.0, 0.91, tolerance=0.1)
   end subroutine test_equal_within_tolerance

   ! Check that integer expected is acceptable
   @test
   subroutine test_integer_expected()
      @assertEqual(1, 1.0)
      @assertEqual(1, 1.0d0)
   end subroutine test_integer_expected


   ! Test conformability check
   !@test
   subroutine test_conformability()
      call assertEqual([1.0], [1.0, 1.0])
      call assertExceptionRaised( &
           & 'Arrays not conformable failure: ' // new_line('a') // &
           & '   Expected shape: [1]' // new_line('a') // &
           & '   Actual shape:   [2]' &
           & )
   end subroutine test_conformability


   ! Test formatting of failure messages
   @test
   subroutine test_equal_fail()
      call assertEqual(1.0, 2.0)
      call assertExceptionRaised(&
           & 'AssertEqual failure:' // new_line('a') // &
           & '      Expected: <1.000000>' // new_line('a') // &
           & '        Actual: <2.000000>' // new_line('a') // &
           & '    Difference: <1.000000> (greater than tolerance of 0.)' &
           & )
   end subroutine test_equal_fail


  ! Same rank, different shape.
  !@test
  subroutine testEquals_1D_nonConformable1()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual


    integer, dimension(2) :: expected
    real(kind=REAL32), dimension(1) :: found

    character(len=:), allocatable :: msg

    allocate(msg, source='testEquals_2D_nonConformable1')

    ! The following should throw an exception...

    expected = good; found = good
    
    call assertEqual(expected, found, msg)

    call assertCatch( &
         & appendWithSpace(msg, & 
         & 'nonconforming arrays - expected shape: ' // &
         & trim(toString(shape(expected))) // ' but found shape: ' // &
         & trim(toString(shape(found)))) &
         & )

    deallocate(msg)
    
  end subroutine testEquals_1D_nonConformable1

  !@test
  subroutine testEquals_2D_SingleElementDifferent()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual


    real, dimension(2,2) :: expected, found

    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2

    character(len=:), allocatable :: msg

    i1 = 1; i2 = 2; expected=good; found=good; found(i1,i2) = bad

    !dbg1 print *,'1000'

    allocate(msg, source='testEquals_2D_SingleElementDifferent')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good,bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

  end subroutine testEquals_2D_SingleElementDifferent

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real(kind=REAL32) :: expected
    real(kind=REAL32), dimension(:,:), allocatable :: found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2

    !dbg1 print *,'2000'

    n1 = 1; n2 = 2; allocate(found(n1,n2))
    expected=good; found=good
    i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg, source='testEquals_MultiD_SingleElementDifferent:Rank0')

    ! The following should throw an exception...
    call assertEqual(expected,found,message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent1
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL32), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2

    !dbg1 print *,'3000'

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good; i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg, source='testEquals_MultiD_SingleElementDifferent:Rank2')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg )

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent1

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent2
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL32), dimension(:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3
    integer :: n1, n2, n3

    !dbg1 print *,'4000'

    n1 = 2; n2 = 3; n3 = 1; allocate(expected(n1,n2,n3),found(n1,n2,n3))
    expected = good; found = good;
    i1 = 1; i2 = 2; i3 = 1; found(i1,i2,i3) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank3')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent2

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent3
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL32), dimension(:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    !dbg1 print *,'5000'

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    expected = good; found = good;
    i1 = 1; i2 = 2; i3 = 1; i4 = 2
    found(i1,i2,i3,i4) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank4')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent3

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent4
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL32), dimension(:,:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4, i5
    integer :: n1, n2, n3, n4, n5

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5),found(n1,n2,n3,n4,n5))
    expected=good; found=good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank5')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent4

  !@test
  subroutine testEquals_MultiD_SingleElementDifferent5
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real(kind=REAL32), dimension(:,:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4, i5
    integer :: n1, n2, n3, n4, n5

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5))
    n1 = 2; n2 = 3; n3 = 2; n4 = 3; n5 = 2;
    allocate(found(n1,n2,n3,n4,n5))
    expected=good; found=good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    !dbg2 print *,'10000'

    allocate(msg,source=&
         & 'testEquals_MultiD_SingleElementDifferent:nonConformable')

    ! The following should throw an exception...
    call assertEqual(expected,found,message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$          & 'nonconforming arrays - expected shape: ' // &
!!$          & trim(toString(shape(expected))) // ' but found shape: ' // &
!!$          & trim(toString(shape(found)))) &
!!$          & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent5

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2

    !dbg3 print *,'11000'

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good
    i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank2')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff1()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3
    integer :: n1, n2, n3

    !dbg3 print *,'12000'

    n1 = 2; n2 = 3; n3 = 1; allocate(expected(n1,n2,n3),found(n1,n2,n3))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; found(i1,i2,i3) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank3')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff1

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff2()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    !dbg3 print *,'13000'

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    expected = good; found = good;
    i1 = 1; i2 = 2; i3 = 1; i4 = 2
    found(i1,i2,i3,i4) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank4')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff2

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff3()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4, i5
    integer :: n1, n2, n3, n4, n5

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5),found(n1,n2,n3,n4,n5))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank5')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff3

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff4()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4, i5
    integer :: n1, n2, n3, n4, n5


    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5))
    n1 = 2; n2 = 3; n3 = 2; n4 = 3; n5 = 2;
    allocate(found(n1,n2,n3,n4,n5))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    allocate(msg,source=&
         & 'testEquals_MultiD_SingleElementDifferent:Rank5:NonConformable')

    ! The following should throw an exception...
    call assertEqual(expected, found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & 'nonconforming arrays - expected shape: ' // &
!!$         & trim(toString(shape(expected))) // ' but found shape: ' // &
!!$         & trim(toString(shape(found)))) &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff4

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff5()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2


    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good
    i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank2')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff5

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff6()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3
    integer :: n1, n2, n3

    n1 = 2; n2 = 3; n3 = 1; allocate(expected(n1,n2,n3),found(n1,n2,n3))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; found(i1,i2,i3) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank3')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff6

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff7()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2
    found(i1,i2,i3,i4) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank4')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff7

  !@test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff8()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4, i5
    integer :: n1, n2, n3, n4, n5

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5),found(n1,n2,n3,n4,n5))
    expected=good; found=good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank5')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad)) // &
!!$         & '; ' // trim(differenceReport(abs(bad - good), 0.)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(expected,found)
    n1 = 2; n2 = 3; n3 = 2; n4 = 2; n5 = 2;
    allocate(expected(n1,n2,n3,n4,n5))
    n1 = 2; n2 = 3; n3 = 2; n4 = 3; n5 = 2;
    allocate(found(n1,n2,n3,n4,n5))
    expected=good; found=good
    i1 = 1; i2 = 2; i3 = 1; i4 = 2; i5 = 1
    found(i1,i2,i3,i4,i5) = bad

    deallocate(msg)
    allocate(msg, source= &
         & 'testEquals_MultiD_SingleElementDifferent:Rank5:NonConformable')

    ! The following should throw an exception...
    call assertEqual(expected,found,message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & 'nonconforming arrays - expected shape: ' // &
!!$         & trim(toString(shape(expected))) // ' but found shape: ' // &
!!$         & trim(toString(shape(found)))) &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff8

  !@test
  subroutine testEquals_ScalarWithTolerance()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL32) :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    real(kind=REAL32) :: tolerance32, bad32

    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    found = bad32

    allocate(msg,source= &
         & 'testEquals_ScalarWithTolerance')

    ! The following should throw an exception...
    ! call assertEqual(expected,found,tolerance = tolerance32, message=msg)
    call assertEqual(expected,found,tolerance32, message=msg)
!!$
!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad32)) // &
!!$         & '; ' // trim(differenceReport(abs(bad32 - good), tolerance32)) // &
!!$         & '.' ))

!mlr-         & ';  first difference at element  [1].') &
!mlr-         & )

    deallocate(msg)

  end subroutine testEquals_ScalarWithTolerance

  !@test
  subroutine testEquals_ScalarWithToleranceNoMsg()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

!    real(kind=REAL32) :: expected, found, tolerance32
    real :: expected, found, tolerance32

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    real(kind=REAL32) :: bad32

    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    found = bad32

    allocate(msg,source='')

    ! The following should throw an exception...
    ! call assertEqual(expected,found,tolerance = tolerance32, message=msg)
    ! call assertEqual(expected,found,tolerance32, message=msg)
    call assertEqual(expected,found,tolerance32)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad32)) // &
!!$         & '; ' // trim(differenceReport(abs(bad32 - good), tolerance32)) // &
!!$         & '.' ))

!mlr-         & ';  first difference at element  [1].') &
!mlr-         & )

    deallocate(msg)

  end subroutine testEquals_ScalarWithToleranceNoMsg

  !@test
  subroutine testEquals_VectorWithToleranceNoMsg()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL32), dimension(3) :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80

    real(kind=REAL32) :: tolerance32, bad32

    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    found(2) = bad32

    allocate(msg,source='')

    ! The following should throw an exception...
    ! call assertEqual(expected,found,tolerance = tolerance32, message=msg)
    ! call assertEqual(expected,found,tolerance32, message=msg)
    call assertEqual(expected,found,tolerance32)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad32)) // &
!!$         & '; ' // trim(differenceReport(abs(bad32 - good), tolerance32)) // &
!!$         & ';  first difference at element [2].') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_VectorWithToleranceNoMsg

  !@test
  subroutine testEquals_MultiDWithTolerance()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL32), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2
    real(kind=REAL32) :: tolerance32, bad32

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    i1 = 1; i2 = 2; 
    found(i1,i2) = bad32

    allocate(msg,source= &
         & 'testEquals_MultiDSingleEltTol32-Throw:Rank2,Tolerance32')

    ! The following should throw an exception...
    call assertEqual(expected,found,tolerance = tolerance32, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good, bad32)) // &
!!$         & '; ' // trim(differenceReport(abs(bad32 - good), tolerance32)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDWithTolerance


  !@test
  subroutine testEquals_MultiDWithTolerance1()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL32), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2
    real(kind=REAL32)    :: tolerance32, bad32

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32/2.0

    i1 = 1; i2 = 2; 
    found(i1,i2) = bad32

    allocate(msg,source= &
         & 'testEquals_MultiDSingleEltTol32-NoThrow:Rank2,Tolerance32')

    ! The following should not throw an exception...
    call assertEqual(expected,found,tolerance = tolerance32, message=msg)

    deallocate(msg)

  end subroutine testEquals_MultiDWithTolerance1

  !@test
  subroutine testEquals_MultiDWithTolerance64()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg
    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2
    real(kind=REAL64)    :: tolerance64, good64, bad64

    good64 = good

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good;

    tolerance64 = 0.01
    bad64 = good64 + tolerance64*2.0

    i1 = 1; i2 = 2; 
    found(i1,i2) = bad64

    allocate(msg,source= &
         & 'testEquals_MultiDSingleEltTol64-Throw:Rank2,Tolerance64')

    ! The following should throw an exception...
    call assertEqual(expected,found,tolerance = tolerance64, message=msg)


! Fix the need for the real below.  Note we're just reporting at this stage, not calculating.
!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good64, bad64)) // &
!!$         & '; ' // trim(differenceReport(abs(bad64 - good64), tolerance64)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

end subroutine testEquals_MultiDWithTolerance64

  !@test
  subroutine testEquals_MultiDWithTolerance64_1()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2
    real(kind=REAL64)    :: tolerance64, good64, bad64

    good64 = good

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good64; found = good64;

    tolerance64 = 0.01
    bad64 = good64 + tolerance64/2.0

    i1 = 1; i2 = 2; 
    found(i1,i2) = bad64

    allocate(msg,source= &
         & 'testEquals_MultiDSingleEltTol64-NoThrow:Rank2,Tolerance64')

    ! The following should not throw an exception...
    call assertEqual(expected,found,tolerance = tolerance64, message=msg)

    deallocate(msg)

  end subroutine testEquals_MultiDWithTolerance64_1


  !@test
  subroutine testEquals_MultiDWithTolerance64_2()
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual
    implicit none

    real(kind=REAL64), dimension(:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3
    integer :: n1, n2, n3
    real(kind=REAL64)    :: tolerance64, good64, bad64

    good64 = good

    n1 = 1; n2 = 2; n3 = 2; allocate(expected(n1,n2,n3),found(n1,n2,n3))
    expected = good64; found = good64

    tolerance64 = 0.01
    bad64 = good64 + tolerance64*2.0

    i1 = 1; i2 = 2; i3 = 1
    found(i1,i2,i3) = bad64

    allocate(msg,source= &
         & 'testEquals_MultiDSingleEltTol64-Throw:Rank3,Tolerance64')

    ! The following should throw an exception...
    call assertEqual(expected,found,tolerance=tolerance64, message=msg)

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good64,bad64)) // &
!!$         & '; ' // trim(differenceReport(abs(bad64 - good64), tolerance64)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDWithTolerance64_2

  !@test
  subroutine testEquals_MultiDSourceLocation()
    use PF_Params_mod
    implicit none

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg
    real(kind=REAL64) :: tolerance64, good64, bad64

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2
    integer :: n1, n2
    type (SourceLocation) :: location

    good64 = good
    
    n1 = 2; n2 = 3; allocate(expected(n1,n2),found(n1,n2))
    expected = good64; found = good64

    tolerance64 = 0.01
    bad64 = good64 + tolerance64*2.0

    i1 = 2; i2 = 3; found(i1,i2) = bad64

    location = SourceLocation(lineNumber=999,fileName='AFileName')

    allocate(msg,source='testEquals_MultiDSourceLocation')

    ! The following should throw an exception...
    call assertEqual(expected,found,tolerance = tolerance64, message=msg, &
         & location=location)

    ! location = SourceLocation(lineNumber=998,fileName='AFileName2')

!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good64, bad64)) // &
!!$         & '; ' // trim(differenceReport(abs(bad64 - good64), tolerance64)) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.'), &
!!$         & location=location &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiDSourceLocation

  !@test
  subroutine testEquals_ScalarAndLocation()
    use PF_Params_mod
    implicit none

    real(kind=REAL64) :: expected, found

    character(len=:), allocatable :: msg
    real(kind=REAL64) :: tolerance64

    !mlr maybe move this to a larger scope...
!    integer, parameter :: MAXLEN_SHAPE = 80
!    type (SourceLocation) :: location

    tolerance64 = 0.0
    expected = 2.0
    found = 3.0

!    location = SourceLocation(lineNumber=999,fileName='AFileName')

    allocate(msg,source='')

    call assertEqual(expected,found,msg)

    ! location = SourceLocation(lineNumber=998,fileName='AFileName2')

! Note use PF_of real...  Consider overloading the reporting functions...
!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(expected, found)) // &
!!$         & '; ' // trim(differenceReport(abs(expected - found), tolerance64)) // &
!!$         &  '.' ) )
    deallocate(msg)

  end subroutine testEquals_ScalarAndLocation

  !@test
  subroutine testEquals_ScalarInf_equal()
    use MakeInf_mod, only:  makeInf_64, makeInf_32

    call assertEqual(makeInf_32(), makeInf_32(), 'equal inf 32')
!!$    call assertEqual(makeInf_64(), makeInf_64(), 'equal inf 64')
!!$
!!$    call assertEqual(makeInf_32(), [makeInf_32(), makeInf_32()], 'equal inf array')

  end subroutine testEquals_ScalarInf_equal

  !@test
  subroutine testEquals_ScalarInf_unequal_A()
    use MakeInf_mod, only: makeInf_64
    
!!$    call assertEqual(1.d0, makeInf_64(), 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  '.' ) )

  end subroutine testEquals_ScalarInf_unequal_A

  !@test
  subroutine testEquals_ScalarInf_unequal_B()
    use MakeInf_mod, only: makeInf_64
    
!!$    call assertEqual(makeInf_64(), 1.0d0, 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(makeInf_64(), 1.0d0)) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  '.' ) )

  end subroutine testEquals_ScalarInf_unequal_B

  !@test
  subroutine testEquals_ScalarInf_unequal_C()
    use MakeInf_mod, only: makeInf_64
    
!!$    call assertEqual(1.d0, [makeInf_64(), 1.d0], 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  ';  first difference at element [1].' ) )


!!$    call assertEqual(1.d0, [1.d0, makeInf_64()], 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  ';  first difference at element [2].' ) )

  end subroutine testEquals_ScalarInf_unequal_C

  !@test
  subroutine testEquals_MultiD_SingleElementGT1
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1
    real, parameter :: bad  = 999

    real(kind=REAL32), dimension(:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    !dbg1 print *,'5000'

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    expected = good+1; found = good;
    i1 = 1; i2 = 2; i3 = 1; i4 = 2
    found(i1,i2,i3,i4) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementGT1')

    ! The following should throw an exception...
    call assertGreaterThan(expected,found, message=msg)


!!$    call assertCatch( &
!!$         & appendWithSpace(msg, &
!!$         & trim(valuesReport(good+1, bad, & 
!!$         &      ePrefix='expected', &
!!$         &      fPrefix='to be greater than:' )) // &
!!$         & ';  first difference at element ' // trim(locationInArray) // '.') &
!!$         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementGT1

  !@test
  subroutine testEquals_MultiD_SingleElementGT2
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1

    real(kind=REAL32), dimension(:,:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
!    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    !dbg1 print *,'5000'

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    expected = good+1; found = good;
!    i1 = 1; i2 = 2; i3 = 1; i4 = 2

    allocate(msg,source='testEquals_MultiD_SingleElementGT2')

    ! The following should not throw an exception...
    call assertGreaterThan(expected,found, message=msg)


!    call assertCatch( &
!         & appendWithSpace(msg, &
!         & trim(valuesReport(good+1, good, & 
!         &      ePrefix='expected', &
!         &      fPrefix='to be greater than:' )) // &
!         & ';  first difference at element ' // trim(locationInArray) // '.') &
!         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementGT2

  !@test
  subroutine testEquals_MultiD_SingleEltVarious1
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1

    real(kind=REAL32), dimension(:,:,:,:), allocatable :: expected, found
    real(kind=REAL32) :: tolerance32

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80
    integer :: i1, i2, i3, i4
    integer :: n1, n2, n3, n4

    !dbg1 print *,'5000'

    n1 = 2; n2 = 3; n3 = 2; n4 = 2; 
    allocate(expected(n1,n2,n3,n4),found(n1,n2,n3,n4))
    i1 = 1; i2 = 2; i3 = 1; i4 = 2

    allocate(msg,source='testEquals_MultiD_SingleEltVarious1')

    ! The following should not throw an exception...

    expected = good; found = good;
    call assertEqual(expected, found, message=msg)

    expected = good+1; found = good;
    call assertGreaterThan(expected, found, message=msg)

    expected = good+1; found = good; found(i1,i2,i3,i4) = good+1
    call assertGreaterThanOrEqual(expected, found, message=msg)

    expected = good; found = good+1;
    call assertLessThan(expected, found, message=msg)

    expected = good; found = good+1; found(i1,i2,i3,i4) = good
    call assertLessThanOrEqual(expected, found, message=msg)

    tolerance32 = 0.001
    expected = good; found = good + tolerance32*0.5;
    call assertRelativelyEqual(expected, found, tolerance32, message=msg )

!    call assertCatch( &
!         & appendWithSpace(msg, &
!         & trim(valuesReport(good+1, good, & 
!         &      ePrefix='expected', &
!         &      fPrefix='to be greater than:' )) // &
!         & ';  first difference at element ' // trim(locationInArray) // '.') &
!         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleEltVarious1

  !@test
  subroutine testEquals_MultiD_SingleEltVarious2
    use PF_Params_mod
!    use PF_Assert_mod, only: assertEqual

    real, parameter :: good = 1

    real(kind=REAL32) :: expected, found
    real(kind=REAL32) :: tolerance32

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer, parameter :: MAXLEN_SHAPE = 80

    !dbg1 print *,'5000'

    allocate(msg,source='testEquals_MultiD_SingleEltVarious2')

    ! The following should not throw an exception...

    expected = good; found = good;
    call assertEqual(expected, found, message=msg)

    expected = good+1; found = good;
    call assertGreaterThan(expected, found, message=msg)

    expected = good+1; found = good; found = good+1
    call assertGreaterThanOrEqual(expected, found, message=msg)

    expected = good; found = good+1;
    call assertLessThan(expected, found, message=msg)

    expected = good; found = good+1; found = good
    call assertLessThanOrEqual(expected, found, message=msg)

    tolerance32 = 0.001
    expected = good; found = good + tolerance32*0.5;
    call assertRelativelyEqual(expected, found, tolerance32, message=msg )


!    call assertCatch( &
!         & appendWithSpace(msg, &
!         & trim(valuesReport(good+1, good, & 
!         &      ePrefix='expected', &
!         &      fPrefix='to be greater than:' )) // &
!         & ';  first difference at element ' // trim(locationInArray) // '.') &
!         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleEltVarious2



  ! Check to see that the test result is as expected...
  !@test
  subroutine assertCatch(string,location)
    use PF_Params_mod
    use PF_Exception_mod, only: Exception
    use PF_ExceptionList_mod, only: getNumExceptions, catchNext
    use PF_Assert_mod, only: assertEqual
    character(len=*), intent(in) :: string
    type (SourceLocation), optional, intent(in) :: location
    type (Exception) :: anException

    if (getNumExceptions() > 0) then
       anException = catchNext()

       !, 'exceptions do not match')
       call assertEqual(string,anException%getMessage()) ! ,message='Exception message test')
       if(present(location))then
          call assertEqual( &
               & location%lineNumber,anException%getLineNumber(), &
               & message='Source line number test')
          call assertEqual(location%fileName,anException%getFileName(), &
               & message='Source file name test')
       end if
    else
       !, 'missing exception')
       call assertEqual(string, ' ')
    end if
  end subroutine assertCatch
   
end module newTest_AssertReal_mod
   
