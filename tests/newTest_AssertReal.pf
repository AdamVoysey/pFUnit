! Goal is not to exhaustively test all combinations, but rather at least
! one variant along each axis:
! Reference comparison:  default real scalar

! Axes:

! 0) true vs fail (both in each test with failure second and check on
!    format of assert message)
! 1) comparison: ==, <, <=,  >, >=
! 2) rank expected
! 3) rank actual
! 4) kind_expected  (int, ...)
! 5) kind_found
! 6) tolerance:  absent, present, 
! 7) Inf expected
! 8) Inf found
! 9) With user-message


module newTest_AssertReal_mod
   use, intrinsic :: iso_fortran_env, only: REAL32, REAL64
   use, intrinsic :: iso_fortran_env, only: REAL128
   use pf_StringUtilities_mod
   use pf_SourceLocation_mod
   use pf_Exceptionlist_mod
   use FUnit, only: SourceLocation, throw, anyExceptions, AssertExceptionRaised
   use pf_AssertReal_0d_mod
   use pf_AssertReal_1d_mod
   use pf_AssertReal_2d_mod
   use pf_AssertReal_3d_mod
#ifdef _REAL32_IEEE_SUPPORT
      use MakeInf_mod, only:  makeInf_32
#endif
#ifdef _REAL64_IEEE_SUPPORT
      use MakeInf_mod, only:  makeInf_64
#endif
#ifdef _REAL128_IEEE_SUPPORT
      use MakeInf_mod, only:  makeInf_128
#endif
   implicit none
      
   @suite(name='AssertReal_suite')

   real(kind=REAL32), parameter :: good = 1
   real(kind=REAL32), parameter :: bad  = -999

contains


   ! First a series of tests that should not raise exceptions.

   @test
   subroutine test_equal_scalar()
      @assertEqual(1, 1.0)
      @assertEqual(1.0, 1.0)
      @assertEqual(1.0, 1.0)

#ifdef _REAL32
      @assertEqual(1, 1.0_REAL32)
      @assertEqual(1.0, 1.0_REAL32)
      @assertEqual(1.0_REAL32, 1.0_REAL32)
#endif

#ifdef _REAL64
      @assertEqual(1, 1.0_REAL64)
      @assertEqual(1.0, 1.0_REAL64)
      @assertEqual(1.0_REAL64, 1.0_REAL64)
#endif

#ifdef _REAL128
      @assertEqual(1, 1.0_REAL128)
      @assertEqual(1.0, 1.0_REAL128)
      @assertEqual(1.0_REAL128, 1.0_REAL128)
#endif
   end subroutine test_equal_scalar

   @test
   subroutine test_equal_scalar_with_tolerance()
      @assertEqual(1, 1.1, 0.2)
      @assertEqual(1.0, 1.1, 0.2)
      @assertEqual(1.0, 1.1, 0.2)

#ifdef _REAL32
      @assertEqual(1, 1.1_REAL32, 0.2)
      @assertEqual(1.0, 1.1_REAL32, 0.2)
      @assertEqual(1.0_REAL32, 1.1_REAL32, 0.2)

      @assertEqual(1, 1.1_REAL32, 0.2_REAL32)
      @assertEqual(1.0, 1.1_REAL32, 0.2_REAL32)
      @assertEqual(1.0_REAL32, 1.1_REAL32, 0.2_REAL32)
#endif
      
#ifdef _REAL64
      @assertEqual(1, 1.1_REAL64, 0.2)
      @assertEqual(1.0, 1.1_REAL64, 0.2)
      @assertEqual(1.0_REAL64, 1.1_REAL64, 0.2)

      @assertEqual(1, 1.1_REAL64, 0.2_REAL64)
      @assertEqual(1.0, 1.1_REAL64, 0.2_REAL64)
      @assertEqual(1.0_REAL64, 1.1_REAL64, 0.2_REAL64)
#endif

#ifdef _REAL128
      @assertEqual(1, 1.1_REAL128, 0.2)
      @assertEqual(1.0, 1.1_REAL128, 0.2)
      @assertEqual(1.0_REAL128, 1.1_REAL128, 0.2)

      @assertEqual(1, 1.1_REAL128, 0.2_REAL128)
      @assertEqual(1.0, 1.1_REAL128, 0.2_REAL128)
      @assertEqual(1.0_REAL128, 1.1_REAL128, 0.2_REAL128)
#endif

   end subroutine test_equal_scalar_with_tolerance

   @test
   subroutine test_equal_1D_actual
      @assertEqual(1, [1.0])
      @assertEqual(1.0, [1.0,1.0,1.0])
      @assertEqual(1.0, [1.0,1.0,1.0])
      @assertEqual([1,2], [1.0,2.0])
      @assertEqual([1.0,2.0], [1.0,2.0])
      @assertEqual([1.0,2.0], [1.0,2.0])

#ifdef _REAL32
      @assertEqual(1, [1.0_REAL32])
      @assertEqual(1.0, [1.0_REAL32,1.0_REAL32,1.0_REAL32])
      @assertEqual(1.0_REAL32, [1.0_REAL32,1.0_REAL32,1.0_REAL32])
      @assertEqual([1,2], [1.0_REAL32,2.0_REAL32])
      @assertEqual([1.0,2.0], [1.0_REAL32,2.0_REAL32])
      @assertEqual([1.0_REAL32,2.0_REAL32], [1.0_REAL32,2.0_REAL32])
#endif

#ifdef _REAL64
      @assertEqual(1, [1.0_REAL64])
      @assertEqual(1.0, [1.0_REAL64,1.0_REAL64,1.0_REAL64])
      @assertEqual(1.0_REAL64, [1.0_REAL64,1.0_REAL64,1.0_REAL64])
      @assertEqual([1,2], [1.0_REAL64,2.0_REAL64])
      @assertEqual([1.0,2.0], [1.0_REAL64,2.0_REAL64])
      @assertEqual([1.0_REAL64,2.0_REAL64], [1.0_REAL64,2.0_REAL64])
#endif


#ifdef _REAL128
      @assertEqual(1, [1.0_REAL128])
      @assertEqual(1.0, [1.0_REAL128,1.0_REAL128,1.0_REAL128])
      @assertEqual(1.0_REAL128, [1.0_REAL128,1.0_REAL128,1.0_REAL128])
      @assertEqual([1,2], [1.0_REAL128,2.0_REAL128])
      @assertEqual([1.0,2.0], [1.0_REAL128,2.0_REAL128])
      @assertEqual([1.0_REAL128,2.0_REAL128], [1.0_REAL128,2.0_REAL128])
#endif
      
   end subroutine test_equal_1D_actual

   @test
   subroutine test_equal_1D_actual_with_tolerance

      @assertEqual(1, [1.1], 0.2)
      @assertEqual(1.0, [1.1,1.1,1.1], 0.2)
      @assertEqual(1.1, [1.1,1.1,1.1],0.2)
      @assertEqual([1,2], [1.1,2.1], 0.2)
      @assertEqual([1.0,2.0], [1.1,2.1], 0.2)
      @assertEqual([1.1,2.1], [1.1,2.1], 0.2)

#ifdef _REAL32      
      @assertEqual(1, [1.1_REAL32], 0.2)
      @assertEqual(1.0, [1.1_REAL32,1.1_REAL32,1.1_REAL32], 0.2)
      @assertEqual(1.1_REAL32, [1.1_REAL32,1.1_REAL32,1.1_REAL32],0.2)
      @assertEqual([1,2], [1.1_REAL32,2.1_REAL32], 0.2)
      @assertEqual([1.0,2.0], [1.1_REAL32,2.1_REAL32], 0.2)
      @assertEqual([1.1_REAL32,2.1_REAL32], [1.1_REAL32,2.1_REAL32], 0.2)

      @assertEqual(1, [1.1_REAL32], 0.2_REAL32)
      @assertEqual(1.0, [1.1_REAL32,1.1_REAL32,1.1_REAL32], 0.2_REAL32)
      @assertEqual(1.1_REAL32, [1.1_REAL32,1.1_REAL32,1.1_REAL32],0.2_REAL32)
      @assertEqual([1,2], [1.1_REAL32,2.1_REAL32], 0.2_REAL32)
      @assertEqual([1.0,2.0], [1.1_REAL32,2.1_REAL32], 0.2_REAL32)
      @assertEqual([1.1_REAL32,2.1_REAL32], [1.1_REAL32,2.1_REAL32], 0.2_REAL32)
#endif

#ifdef _REAL64
      @assertEqual(1, [1.1_REAL64], 0.2)
      @assertEqual(1.0, [1.1_REAL64,1.1_REAL64,1.1_REAL64], 0.2)
      @assertEqual(1.1_REAL64, [1.1_REAL64,1.1_REAL64,1.1_REAL64],0.2)
      @assertEqual([1,2], [1.1_REAL64,2.1_REAL64], 0.2)
      @assertEqual([1.0,2.0], [1.1_REAL64,2.1_REAL64], 0.2)
      @assertEqual([1.1_REAL64,2.1_REAL64], [1.1_REAL64,2.1_REAL64], 0.2)

      @assertEqual(1, [1.1_REAL64], 0.2_REAL64)
      @assertEqual(1.0, [1.1_REAL64,1.1_REAL64,1.1_REAL64], 0.2_REAL64)
      @assertEqual(1.1_REAL64, [1.1_REAL64,1.1_REAL64,1.1_REAL64],0.2_REAL64)
      @assertEqual([1,2], [1.1_REAL64,2.1_REAL64], 0.2_REAL64)
      @assertEqual([1.0,2.0], [1.1_REAL64,2.1_REAL64], 0.2_REAL64)
      @assertEqual([1.1_REAL64,2.1_REAL64], [1.1_REAL64,2.1_REAL64], 0.2_REAL64)
#endif

#ifdef _REAL128
      @assertEqual(1, [1.1_REAL128], 0.2)
      @assertEqual(1.0, [1.1_REAL128,1.1_REAL128,1.1_REAL128], 0.2)
      @assertEqual(1.1_REAL128, [1.1_REAL128,1.1_REAL128,1.1_REAL128],0.2)
      @assertEqual([1,2], [1.1_REAL128,2.1_REAL128], 0.2)
      @assertEqual([1.0,2.0], [1.1_REAL128,2.1_REAL128], 0.2)
      @assertEqual([1.1_REAL128,2.1_REAL128], [1.1_REAL128,2.1_REAL128], 0.2)

      @assertEqual(1, [1.1_REAL128], 0.2_REAL128)
      @assertEqual(1.0, [1.1_REAL128,1.1_REAL128,1.1_REAL128], 0.2_REAL128)
      @assertEqual(1.1_REAL128, [1.1_REAL128,1.1_REAL128,1.1_REAL128],0.2_REAL128)
      @assertEqual([1,2], [1.1_REAL128,2.1_REAL128], 0.2_REAL128)
      @assertEqual([1.0,2.0], [1.1_REAL128,2.1_REAL128], 0.2_REAL128)
      @assertEqual([1.1_REAL128,2.1_REAL128], [1.1_REAL128,2.1_REAL128], 0.2_REAL128)
#endif
      
   end subroutine test_equal_1D_actual_with_tolerance

   
   @test
   subroutine test_equal_2D_actual
      integer :: const(2,3) = reshape([1,1,1,1,1,1],[2,3])
      integer :: array(2,3) = reshape([1,2,3,4,5,6],[2,3])
      
      @assertEqual(1, real(const))
      @assertEqual(1.0, real(const))

      @assertEqual(array, real(array))
      @assertEqual(real(array), real(array))

#ifdef _REAL32
      @assertEqual(1, real(const,kind=REAL32))
      @assertEqual(1.0, real(const,kind=REAL32))
      @assertEqual(1.0_REAL32, real(const,kind=REAL32))

      @assertEqual(array, real(array,kind=REAL32))
      @assertEqual(real(array), real(array,kind=REAL32))
      @assertEqual(real(array,kind=REAL32), real(array,kind=REAL32))
#endif

#ifdef _REAL64
      @assertEqual(1, real(const,kind=REAL64))
      @assertEqual(1.0, real(const,kind=REAL64))
      @assertEqual(1.0_REAL64, real(const,kind=REAL64))

      @assertEqual(array, real(array,kind=REAL64))
      @assertEqual(real(array), real(array,kind=REAL64))
      @assertEqual(real(array,kind=REAL64), real(array,kind=REAL64))
#endif


#ifdef _REAL128
      @assertEqual(1, real(const,kind=REAL128))
      @assertEqual(1.0, real(const,kind=REAL128))
      @assertEqual(1.0_REAL128, real(const,kind=REAL128))

      @assertEqual(array, real(array,kind=REAL128))
      @assertEqual(real(array), real(array,kind=REAL128))
      @assertEqual(real(array,kind=REAL128), real(array,kind=REAL128))
#endif
      
   end subroutine test_equal_2D_actual

   @test
   subroutine test_equal_2D_actual_with_tolerance
      integer :: const(2,3) = reshape([1,1,1,1,1,1],[2,3])
      integer :: array(2,3) = reshape([1,2,3,4,5,6],[2,3])
      
      @assertEqual(1, real(const)+1, 2.)
      @assertEqual(1.0, real(const)+1, 2.)

      @assertEqual(array, real(array)+1, 2.)
      @assertEqual(real(array), real(array)+1,2.)

#ifdef _REAL32
      @assertEqual(1, real(const,kind=REAL32)+1, 2._REAL32)
      @assertEqual(1.0, real(const,kind=REAL32)+1, 2._REAL32)
      @assertEqual(1.0_REAL32, real(const,kind=REAL32)+1, 2._REAL32)

      @assertEqual(array, real(array,kind=REAL32)+1, 2._REAL32)
      @assertEqual(real(array), real(array,kind=REAL32)+1, 2._REAL32)
      @assertEqual(real(array,kind=REAL32), real(array,kind=REAL32)+1, 2._REAL32)

      @assertEqual(1, real(const,kind=REAL32)+1, 2.)
      @assertEqual(1.0, real(const,kind=REAL32)+1, 2.)
      @assertEqual(1.0_REAL32, real(const,kind=REAL32)+1, 2.)

      @assertEqual(array, real(array,kind=REAL32)+1, 2.)
      @assertEqual(real(array), real(array,kind=REAL32)+1, 2.)
      @assertEqual(real(array,kind=REAL32), real(array,kind=REAL32)+1, 2.)
#endif

#ifdef _REAL64
      @assertEqual(1, real(const,kind=REAL64)+1, 2._REAL64)
      @assertEqual(1.0, real(const,kind=REAL64)+1, 2._REAL64)
      @assertEqual(1.0_REAL64, real(const,kind=REAL64)+1, 2._REAL64)

      @assertEqual(array, real(array,kind=REAL64)+1, 2._REAL64)
      @assertEqual(real(array), real(array,kind=REAL64)+1, 2._REAL64)
      @assertEqual(real(array,kind=REAL64), real(array,kind=REAL64)+1, 2._REAL64)

      @assertEqual(1, real(const,kind=REAL64)+1, 2.)
      @assertEqual(1.0, real(const,kind=REAL64)+1, 2.)
      @assertEqual(1.0_REAL64, real(const,kind=REAL64)+1, 2.)

      @assertEqual(array, real(array,kind=REAL64)+1, 2.)
      @assertEqual(real(array), real(array,kind=REAL64)+1, 2.)
      @assertEqual(real(array,kind=REAL64), real(array,kind=REAL64)+1, 2.)
#endif


#ifdef _REAL128
      @assertEqual(1, real(const,kind=REAL128)+1, 2._REAL128)
      @assertEqual(1.0, real(const,kind=REAL128)+1, 2._REAL128)
      @assertEqual(1.0_REAL128, real(const,kind=REAL128)+1, 2._REAL128)

      @assertEqual(array, real(array,kind=REAL128)+1, 2._REAL128)
      @assertEqual(real(array), real(array,kind=REAL128)+1, 2._REAL128)
      @assertEqual(real(array,kind=REAL128), real(array,kind=REAL128)+1, 2._REAL128)

      @assertEqual(1, real(const,kind=REAL128)+1, 2.)
      @assertEqual(1.0, real(const,kind=REAL128)+1, 2.)
      @assertEqual(1.0_REAL128, real(const,kind=REAL128)+1, 2.)

      @assertEqual(array, real(array,kind=REAL128)+1, 2.)
      @assertEqual(real(array), real(array,kind=REAL128)+1, 2.)
      @assertEqual(real(array,kind=REAL128), real(array,kind=REAL128)+1, 2.)
#endif
      
   end subroutine test_equal_2D_actual_with_tolerance

   ! Ensure that Infinity does not cause floating exceptions
   @test
   subroutine test_infinity()
#ifdef _REAL32_IEEE_SUPPORT
      call assertEqual(makeInf_32(), makeInf_32())
#endif
#ifdef _REAL64_IEEE_SUPPORT
      call assertEqual(makeInf_64(), makeInf_64())
#endif
#ifdef _REAL128_IEEE_SUPPORT
      call assertEqual(makeInf_128(), makeInf_128())
#endif

   end subroutine test_infinity

   @test
   subroutine test_infinity_1d()

#ifdef _REAL32_IEEE_SUPPORT
      call assertEqual([1._REAL32,makeInf_32()], [1._REAL32,makeInf_32()])
#endif
#ifdef _REAL64_IEEE_SUPPORT
      call assertEqual([1._REAL64,makeInf_64()], [1._REAL64,makeInf_64()])
#endif
#ifdef _REAL128_IEEE_SUPPORT
      call assertEqual([1._REAL128,makeInf_128()], [1._REAL128,makeInf_128()])
#endif

   end subroutine test_infinity_1d

   

   ! Test conformability check
   @test
   subroutine test_conformability()
      call assertEqual([1.0], [1.0, 1.0])
      call assertExceptionRaised( &
           & 'Arrays not conformable failure:' // new_line('a') // &
           & '    Expected shape: [1]' // new_line('a') // &
           & '      Actual shape: [2]' &
           & )
   end subroutine test_conformability


   ! Test formatting of failure messages
   @test
   subroutine test_equal_fail()
      call assertEqual(1.0, 2.0)
      call assertExceptionRaised(&
           & 'AssertEqual failure:' // new_line('a') // &
           & '      Expected: <1.000000>' // new_line('a') // &
           & '        Actual: <2.000000>' // new_line('a') // &
           & '    Difference: <1.000000> (greater than tolerance of 0.)' &
           & )
   end subroutine test_equal_fail


  ! Same rank, different shape.
  @test
  subroutine testEquals_1D_nonConformable1()

    integer, dimension(2) :: expected
    real(kind=REAL32), dimension(1) :: found

    character(len=:), allocatable :: msg

    allocate(msg, source='testEquals_1D_nonConformable1')

    ! The following should throw an exception...

    expected = good; found = good
    
    call assertEqual(expected, found, msg)

    call assertExceptionRaised( &
         & msg // new_line('a') // &
         & 'Arrays not conformable failure:' // new_line('a') // &
         & '    Expected shape: [2]' // new_line('a') // &
         & '      Actual shape: [1]' &
         & )

    deallocate(msg)
    
  end subroutine testEquals_1D_nonConformable1

  @test
  subroutine testEquals_2D_SingleElementDifferent()

    real, dimension(2,2) :: expected, found

    integer :: i1, i2

    character(len=:), allocatable :: msg

    i1 = 1; i2 = 2; expected=good; found=good; found(i1,i2) = bad

    allocate(msg, source='testEquals_2D_SingleElementDifferent')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

    call assertExceptionRaised( &
         & msg // new_line('a') // &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000>' // new_line('a') // &
         & '        Actual: <-999.0000>' // new_line('a') // &
         & '    Difference: <-1000.000> (greater than tolerance of 0.)'  // new_line('a') // &
         & '      at index: [1,2]' &
         )

  end subroutine testEquals_2D_SingleElementDifferent

  @test
  subroutine testEquals_MultiD_SingleElementDifferent()

    real(kind=REAL32) :: expected
    real(kind=REAL32), dimension(:,:), allocatable :: found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer :: i1, i2
    integer :: n1, n2

    !dbg1 print *,'2000'

    n1 = 1; n2 = 2; allocate(found(n1,n2))
    expected=good; found=good
    i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg, source='testEquals_MultiD_SingleElementDifferent:Rank0')

    ! The following should throw an exception...
    call assertEqual(expected,found,message=msg)

    call assertExceptionRaised( &
         & msg // new_line('a') // &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000>' // new_line('a') // &
         & '        Actual: <-999.0000>' // new_line('a') // &
         & '    Difference: <-1000.000> (greater than tolerance of 0.)'  // new_line('a') // &
         & '      at index: [1,2]' &
         & )

    deallocate(msg)

  end subroutine testEquals_MultiD_SingleElementDifferent

  @test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff()
    
    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer :: i1, i2
    integer :: n1, n2

    !dbg3 print *,'11000'

    n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
    expected = good; found = good
    i1 = 1; i2 = 2; found(i1,i2) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank2')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

    call assertExceptionRaised( &
         & msg // new_line('a') // &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000000000000>' // new_line('a') // &
         & '        Actual: <-999.0000000000000>' // new_line('a') // &
         & '    Difference: <-1000.000000000000> (greater than tolerance of 0.)'  // new_line('a') // &
         & '      at index: [1,2]' &
         &)

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff

  @test
  subroutine testEquals_MultiDMultiPrec_SingleEltDiff1()
    
    real, parameter :: good = 1
    real, parameter :: bad  = -999

    real(kind=REAL64), dimension(:,:,:), allocatable :: expected, found

    character(len=:), allocatable :: msg

    !mlr maybe move this to a larger scope...
    integer :: i1, i2, i3
    integer :: n1, n2, n3

    !dbg3 print *,'12000'

    n1 = 2; n2 = 3; n3 = 1; allocate(expected(n1,n2,n3),found(n1,n2,n3))
    expected = good; found = good
    i1 = 1; i2 = 2; i3 = 1; found(i1,i2,i3) = bad

    allocate(msg,source='testEquals_MultiD_SingleElementDifferent:Rank3')

    ! The following should throw an exception...
    call assertEqual(expected,found, message=msg)

    call assertExceptionRaised( &
         & msg // new_line('a') // &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000000000000>' // new_line('a') // &
         & '        Actual: <-999.0000000000000>' // new_line('a') // &
         & '    Difference: <-1000.000000000000> (greater than tolerance of 0.)'  // new_line('a') // &
         & '      at index: [1,2,1]' &
         & )

    deallocate(msg)

  end subroutine testEquals_MultiDMultiPrec_SingleEltDiff1

  @test
  subroutine testEquals_ScalarWithTolerance()
    
    real(kind=REAL32) :: expected, found
    real(kind=REAL32) :: tolerance32, bad32

    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    found = bad32

    call assertEqual(expected,found,tolerance32)

    call assertExceptionRaised( &
         & 'AssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000>' // new_line('a') // &
         & '        Actual: <1.020000>' // new_line('a') // &
         & '    Difference: <0.1999998E-01> (greater than tolerance of 0.1000000E-01)' &
         & )

  end subroutine testEquals_ScalarWithTolerance

  @test
  subroutine testEquals_VectorWithToleranceNoMsg()
    
    real(kind=REAL32), dimension(3) :: expected, found

    real(kind=REAL32) :: tolerance32, bad32

    expected = good; found = good;

    tolerance32 = 0.01
    bad32 = good + tolerance32*2.0

    found(2) = bad32

    ! The following should throw an exception...
    ! call assertEqual(expected,found,tolerance = tolerance32, message=msg)
    ! call assertEqual(expected,found,tolerance32, message=msg)
    call assertEqual(expected,found,tolerance32)

    call assertExceptionRaised( &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000>' // new_line('a') // &
         & '        Actual: <1.020000>' // new_line('a') // &
         & '    Difference: <0.1999998E-01> (greater than tolerance of 0.1000000E-01)' // new_line('a') // &
         & '      at index: [2]' &
         & )

  end subroutine testEquals_VectorWithToleranceNoMsg

  @test
  subroutine testEquals_MultiDWithTolerance64()
    
     real(kind=REAL64), dimension(:,:), allocatable :: expected, found

     character(len=:), allocatable :: msg
     !mlr maybe move this to a larger scope...
     integer :: i1, i2
     integer :: n1, n2
     real(kind=REAL64)    :: tolerance64, good64, bad64
     
     good64 = good
     
     n1 = 1; n2 = 2; allocate(expected(n1,n2),found(n1,n2))
     expected = good; found = good;
     
     tolerance64 = 0.01d0
     bad64 = good64 + tolerance64*2.0
     
     i1 = 1; i2 = 2; 
     found(i1,i2) = bad64
     
     ! The following should throw an exception...
     call assertEqual(expected,found,tolerance = tolerance64, message=msg)
     
    call assertExceptionRaised( &
         & 'ArrayAssertEqual failure:' // new_line('a') // &
         & '      Expected: <1.000000000000000>' // new_line('a') // &
         & '        Actual: <1.020000000000000>' // new_line('a') // &
         & '    Difference: <0.2000000000000002E-01> (greater than tolerance of 0.1000000000000000E-01)' // new_line('a') // &
         & '      at index: [1,2]' &
         & )

 end subroutine testEquals_MultiDWithTolerance64


  @test
  subroutine testEquals_ScalarInf_equal()

    call assertEqual(makeInf_32(), makeInf_32(), 'equal inf 32')
    call assertEqual(makeInf_64(), makeInf_64(), 'equal inf 64')
    call assertEqual(makeInf_32(), [makeInf_32(), makeInf_32()], 'equal inf array')

  end subroutine testEquals_ScalarInf_equal

  !@test
  subroutine testEquals_ScalarInf_unequal_A()
    
!!$    call assertEqual(1.d0, makeInf_64(), 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  '.' ) )

  end subroutine testEquals_ScalarInf_unequal_A

  !@test
  subroutine testEquals_ScalarInf_unequal_B()
    use MakeInf_mod, only: makeInf_64
    
!!$    call assertEqual(makeInf_64(), 1.0d0, 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(makeInf_64(), 1.0d0)) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  '.' ) )

  end subroutine testEquals_ScalarInf_unequal_B

  !@test
  subroutine testEquals_ScalarInf_unequal_C()
    use MakeInf_mod, only: makeInf_64
    
!!$    call assertEqual(1.d0, [makeInf_64(), 1.d0], 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  ';  first difference at element [1].' ) )


!!$    call assertEqual(1.d0, [1.d0, makeInf_64()], 'unequal')
!!$    call assertCatch( &
!!$         & appendWithSpace('unequal', &
!!$         & trim(valuesReport(1., makeInf_64())) // &
!!$         & '; ' // trim(differenceReport(makeInf_64(), 0.)) // &
!!$         &  ';  first difference at element [2].' ) )

  end subroutine testEquals_ScalarInf_unequal_C


   
end module newTest_AssertReal_mod
   
