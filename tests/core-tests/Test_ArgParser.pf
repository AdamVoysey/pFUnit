module Test_ArgParser_mod
   use FUnit

   @suite(name='ArgParser_suite')

contains

   @test
   subroutine test_null()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      options = p%parse_args(arguments)

      @assertEqual(0, options%size())
      
   end subroutine test_null

   @test
   subroutine test_one_option_missing_argument()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      options = p%parse_args(arguments)

      @assertEqual(0, options%size())
      
   end subroutine test_one_option_missing_argument

   @test
   subroutine test_one_option_with_argument()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      call arguments%push_back('--arg')
      call p%add_option('--arg', action='store_true')
      options = p%parse_args(arguments)
      @assertEqual(1, options%size())
      
   end subroutine test_one_option_with_argument

   @test
   subroutine test_option_type_logical()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value

      call arguments%push_back('--f1')
      call arguments%push_back('--f2')

      ! present
      call p%add_option('--f1', action='store_true')
      call p%add_option('--f2', action='store_false')

      options = p%parse_args(arguments)

      opt_value => options%at('f1')
      select type (opt_value)
      type is (logical)
         @assertTrue(opt_value)
      class default
         @AssertFail('expected logical')
      end select

      opt_value => options%at('f2')
      select type (opt_value)
      type is (logical)
         @assertFalse(opt_value)
      class default
         @AssertFail('expected logical')
      end select


   end subroutine test_option_type_logical

   @test
   subroutine test_option_type_integer()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value

      call arguments%push_back('-n')
      call arguments%push_back('1')
      

      call p%add_option('-n', type='integer', action='store')
      options = p%parse_args(arguments)

      @assertEqual(1, options%size())
      opt_value => options%at('n')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (integer)
         @AssertEqual(1, opt_value)
      class default
         @AssertFail('expected integer')
      end select

   end subroutine test_option_type_integer

   @test
   subroutine test_option_type_integer_default()
      type (ArgParser) :: p
      type (StringVector) :: arguments, absent
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value
     
      call p%add_option('-n', type='integer', action='store', default=5)
      options = p%parse_args(absent)

      @assertEqual(1, options%size())
      opt_value => options%at('n')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (integer)
         @AssertEqual(5, opt_value)
      class default
         @AssertFail('expected integer')
      end select

      call arguments%push_back('-n')
      call arguments%push_back('3')
      options = p%parse_args(arguments)
      
      @assertEqual(1, options%size())
      opt_value => options%at('n')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (integer)
         @AssertEqual(3, opt_value)
      class default
         @AssertFail('expected integer')
      end select


   end subroutine test_option_type_integer_default


   @test
   subroutine test_option_type_string()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value

      call arguments%push_back('-f')
      call arguments%push_back('foo')
      call p%add_option('-f', type='string', action='store')
      options = p%parse_args(arguments)

      @assertEqual(1, options%size())
      opt_value => options%at('f')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (character(*))
         @AssertEqual('foo', opt_value)
      class default
         @AssertFail('expected string')
      end select

   end subroutine test_option_type_string


   @test
   subroutine test_option_type_real()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value
     
      call arguments%push_back('-x')
      call arguments%push_back('1.234')
      call p%add_option('-x', type='real', action='store')
      options = p%parse_args(arguments)

      @assertEqual(1, options%size())
      opt_value => options%at('x')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (real)
         @AssertEqual(1.234, opt_value)
      class default
         @AssertFail('expected real')
      end select

   end subroutine test_option_type_real

   ! Need to support cases where the option value is in the same argument as the
   ! option specifier.   e.g.  "-n3" should be the equivalent of "-n 3".
   @test
   subroutine test_combo_short_option_string()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value
     
      call p%add_option('-n', type='integer')
      call arguments%push_back('-n3')
      options = p%parse_args(arguments)

      @assertEqual(1, options%size())
      opt_value => options%at('n')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (integer)
         @AssertEqual(3, opt_value)
      class default
         @AssertFail('expected integer')
      end select

   end subroutine test_combo_short_option_string

   ! Long options require an "=" for embedded values:
   ! "--foo=3" is equivalent to "--foo 3"
   @test
   subroutine test_combo_long_option_string()
      type (ArgParser) :: p
      type (StringVector) :: arguments
      type (StringUnlimitedMap) :: options

      class(*), pointer :: opt_value
     
      call p%add_option('--foo', type='integer')
      call arguments%push_back('--foo=3')
      options = p%parse_args(arguments)

      @assertEqual(1, options%size())
      opt_value => options%at('foo')
      @assertAssociated(opt_value)

      select type (opt_value)
      type is (integer)
         @AssertEqual(3, opt_value)
      class default
         @AssertFail('expected integer')
      end select

   end subroutine test_combo_long_option_string

end module Test_ArgParser_mod
